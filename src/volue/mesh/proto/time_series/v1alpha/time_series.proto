syntax = "proto3";

package volue.mesh.grpc.time_series.v1alpha;

import "google/protobuf/field_mask.proto";

import "volue/mesh/proto/model_definition/v1alpha/resources.proto";
import "volue/mesh/proto/type/resources.proto";


// Mesh time series service
// -------------------------------
// The Mesh time series service is an API for managing Mesh time series,
// including reading and writing.
//
// In its simplest form a time series is just a table of timestamps, flags
// and values. Time series can be organized and generated in different ways.
//
// Some time series are retrieved 'as is' from the database where they are
// stored. Such time series are called physical time series. They reside in
// Mesh resources which is a container storing data, that could be used by Mesh
// model(s). Physical time series together with time series data (timestamps,
// values and flags) have also associated metadata (e.g.: curve type,
// resolution, etc.).
//
// Others are generated using calculations which can be based on an arbitrary
// set of data. Such time series are called calculation time series.
//
// There is also third type of time series called virtual time series (VTS).
// Virtual time series has defined an expression to calculate time series data
// (similar to calculation time series) but is stored in Mesh resources, just
// like physical time series.
//
// Physical and virtual time series can be organized in Mesh resources in
// a structure which resembles catalogs and thus can have a path associated
// with it. They can also potentially be connected to a time series attribute
// in a Mesh model.
//
service TimeseriesService {

  // Each time series point occupies 20 bytes. By default, gRPC has a limitation
  // of 4MB inbound message size. In case of larger data volumes please send
  // request data in chunks or increase the maximum gRPC inbound message size
  // from client side.
  // Note: reading points from uncommitted physical time series is not supported.
  // Commit the newly created physical time series to read its points.
  rpc ReadTimeseries(ReadTimeseriesRequest) returns (ReadTimeseriesResponse) {}
  rpc ReadTimeseriesStream(ReadTimeseriesStreamRequest) returns (stream ReadTimeseriesResponse) {}

  // Read batch of time series with applied transformation.
  //
  // Mesh IDs of the returned time series match the requested Mesh IDs.
  // Additionally, the order of responses is guaranteed to match the order of
  // requests. E.g.: in the request user asks for data of 3 time series:
  // Request: [TS_ATTRIBUTE_ID1, TS_ATTRIBUTE_ID2, TS_ATTRIBUTE_ID3]
  // Responses: [TS_ATTRIBUTE_ID1, TS_ATTRIBUTE_ID2, TS_ATTRIBUTE_ID3]
  // Note: reading points from uncommitted physical time series is not supported.
  // Commit the newly created physical time series to read its points.
  rpc ReadTransformedTimeseries(ReadTransformedTimeseriesRequest) returns (stream ReadTimeseriesResponse) {}

  // Each time series point occupies 20 bytes. Mesh server has a limitation of
  // 4MB inbound message size. In case of larger data volumes please send input
  // data in chunks.
  rpc WriteTimeseries(WriteTimeseriesRequest) returns (WriteTimeseriesResponse) {}

  // Get time series resource.
  // A time series resource:
  // - can be either physical or virtual time series
  // - can be connected to time series attributes.
  // - is identified by time series key or path within Resource catalog
  //
  // Physical time series has data (timestamps, values and flags) and
  // metadata (e.g.: curve type, resolution, etc.).
  // Virtual time series has metadata but instead of timestamps, values and
  // flags it has defined an expression to calculate time series data
  // (similar to calculation time series) but is stored in the resources.
  rpc GetTimeseriesResource(GetTimeseriesResourceRequest) returns (TimeseriesResource) {}

  rpc UpdateTimeseriesResource(UpdateTimeseriesResourceRequest) returns (UpdateTimeseriesResourceResponse) {}

  // Copy time series from one part of Mesh model to another part of the model.
  // This method copies time series values from a set of time series (source)
  // to another set of time series (target).
  // The input defines the root nodes of source hierarchy and target hierarchy.
  // In case these root nodes are different, the match between source series
  // and target series is  done by comparison of relative path to series
  // attribute in source and target hierarchy.
  //
  // The function supports a mapping description that enables these operations:
  // - Copy to *another* attribute on the same object as the source series.
  // - Copy to *another* attribute on the matching object in the target
  //   hierarchy.
  // - Copy time series from a source hierarchy to a target identified by
  //   a general search/navigation spec on the mapping definition.
  //
  // In case mapping is enabled, the root nodes for source and target may be
  // the same.
  rpc CopyTimeseriesBetweenObjects(CopyTimeseriesBetweenObjectsRequest) returns (CopyTimeseriesBetweenObjectsResponse) {}

  // Create a new (empty) physical time series resource. Returns the newly
  // created resource.
  //
  // Any missing components of the requested timeseries path will be created in
  // the catalog as well. For example, if we set the CreatePhysicalTimeseriesRequest's
  // 'path' field to "/Path/To/Timeseries/", and its 'name' field to
  // "Test_Timeseries", the entire Path/To/Timeseries/Test_Timeseries sequence
  //  of catalog entries will be created if it doesn't exist already.
  //
  // It is not mandatory that the path mirrors the topology of the Mesh model.
  // The path *must* begin and end with forward slashes.
  //
  // Note that the 'path' field on the returned TimeseriesResource won't
  // have the same as the value as CreatePhysicalTimeseriesRequest's 'path';
  // namely, the returned 'path' will have a "Resource/" prefix, and will be
  // suffixed with the contents of the 'name' field from this request. That is:
  //
  //     response.path == "Resource/" + request.path + "/" + request.name
  //
  // Continuing with the previous example, in this case the 'path' field in the
  // response will be "Resource/Path/To/Timeseries/Test_Timeseries".
  rpc CreatePhysicalTimeseries(CreatePhysicalTimeseriesRequest) returns (TimeseriesResource) {}
}

message ReadTimeseriesRequest {
  volue.mesh.grpc.type.Guid session_id = 1;

  volue.mesh.grpc.type.MeshId timeseries_id = 2;
  volue.mesh.grpc.type.UtcInterval interval = 3;
}

message ReadTimeseriesResponse {
  repeated Timeseries timeseries = 1;
}

message ReadTimeseriesStreamRequest{
  volue.mesh.grpc.type.Guid session_id = 1;

  repeated volue.mesh.grpc.type.MeshId timeseries_ids = 2;
  volue.mesh.grpc.type.UtcInterval interval = 3;
}

message ReadTransformedTimeseriesRequest {
  volue.mesh.grpc.type.Guid session_id = 1;
  repeated ReadTransformedTimeseriesSingleRequest requests = 2;
}

message ReadTransformedTimeseriesSingleRequest {
  volue.mesh.grpc.type.MeshId timeseries_id = 1;
  volue.mesh.grpc.type.UtcInterval interval = 2;
  // Target transformation resolution. Must not be set to break point.
  volue.mesh.grpc.type.Resolution resolution = 3;
  TransformationMethod transformation_method = 4;
  Timezone transformation_timezone = 5;
}

enum TransformationMethod {
  // Defaults to IMPLICIT.
  TRANSFORMATION_METHOD_UNSPECIFIED = 0;
  // Method chosen automatically based on time series type.
  IMPLICIT  = 1;
  // The sum of the values included in the base for this value.
  // Does not consider how long the values are valid, i.e. a break point series
  // with two values in the current interval that will give the sum of these
  // two values.
  SUM       = 2;
  // Integral based sum with resolution second. Calculates the sum of value
  // multiplied with number of seconds each value is valid. Value equal 1 at
  // the start of the day will give 86400 as day value if the base is one break
  // point series and 3600 if this is an hour series with only one value on
  // first hour.
  SUMI      = 3;
  // For fixed interval series. Sum of all values in accumulation period
  // divided by number of values in the accumulation period (24 for hour series
  // that is transformed to day series). For break point series: Mean value of
  // the values included in the base for this value. Does not consider how long
  // the values are valid, i.e. a break point series with two values in the
  // current interval that will give the mean value of these two values.
  AVG       = 4;
  // Integral based mean value, i.e. considers how much of the accumulation
  // period that a given value is valid (to next value that can be NaN for
  // a fixed interval series).
  AVGI      = 5;
  // First value in the accumulation period. For break point series this is the
  // functional value at the start of the accumulation period, unless there
  // exist an explicit value. Please note! For fixed interval series it is the
  // first value not being NaN in the accumulation period.
  FIRST     = 6;
  // Last value in the accumulation period. For break point series this is the
  // functional value at the end of the accumulation period, unless there exist
  // an explicit value. Note! For fixed interval series it is the last value
  // not being NaN in the accumulation period.
  LAST      = 7;
  // Smallest value in the accumulation period.
  MIN       = 8;
  // Largest value in the accumulation period.
  MAX       = 9;
}

enum Timezone {
  // Defaults to UTC.
  TIMEZONE_UNSPECIFIED = 0;
  // Universal Time Coordinated (UTC).
  UTC       = 1;
  // Mesh server local time zone.
  LOCAL     = 2;
  // Mesh server local time zone without Daylight Saving Time (DST).
  STANDARD  = 3;
}

message WriteTimeseriesRequest {
  volue.mesh.grpc.type.Guid session_id = 1;

  // Time series must point to exactly one time series
  // - attribute or source (pointed by path or ID)
  // - physical or virtual (pointed by time series key)
  // The resolution of the points has to fit the stored time series.
  // Otherwise it will be rejected.
  Timeseries timeseries = 2;
}

message WriteTimeseriesResponse {
}

message GetTimeseriesResourceRequest {
  volue.mesh.grpc.type.Guid session_id = 1;

  // Time series key of the time series resource to be returned.
  int64 timeseries_resource_key = 2;
}

// Information about physical or virtual time series.
message TimeseriesResource {
  // Unique identifier for physical or virtual time series.
  // Set to 0 if it is a local session time series.
  // This is the only field that could be used for updating
  // time series attribute with new time series resource.
  int64 timeseries_key = 1;

  string path = 2;

  string name = 3;

  // Set to true if it is a local session time series.
  bool temporary = 4;

  volue.mesh.grpc.type.Curve curve_type = 5;

  volue.mesh.grpc.type.Resolution resolution = 6;

  volue.mesh.grpc.model_definition.v1alpha.UnitOfMeasurement unit_of_measurement = 7;

  string virtual_timeseries_expression = 8;

  optional string time_zone = 9;
}

message Timeseries {
  volue.mesh.grpc.type.MeshId id = 1;

  // [OUTPUT_ONLY] - no need to set when writing time series using
  // `WriteTimeseries`.
  // Resolution/spacing for this timeseries.
  volue.mesh.grpc.type.Resolution resolution = 2;

  // Time interval for this timeseries.
  volue.mesh.grpc.type.UtcInterval interval = 3;

  // Data contains an Apache Arrow byte representation of the time series
  // points. If no points exist empty table will be returned.
  // Stored in the following columns:
  // 0: (timestamp('ms')) utc_time - UTC Unix timestamp expressed in
  //    milliseconds (internally it is stored as a 64-bit integer)
  // 1: (uint32) flags
  // 2: (double) value
  bytes data = 4;
}

message UpdateTimeseriesResourceRequest {
  volue.mesh.grpc.type.Guid session_id = 1;

  // Time series key of the time series resource to be updated.
  int64 timeseries_resource_key = 2;

  // An array containing field names to be updated.
  // For example to update a time series resource curve type and
  // unit of measurement:
  //   field_mask = ['new_curve_type', 'new_unit_of_measurement_id']
  //   new_curve_type = CurveType::PIECEWISELINEAR
  //   new_unit_of_measurement_id = ID of the unit of measurement.
  //
  // All units of measurements can be listed using model definition service
  // `ListUnitsOfMeasurement` RPC.
  google.protobuf.FieldMask field_mask = 3;

  volue.mesh.grpc.type.Curve new_curve_type = 4;

  // To clear the unit of measurement leave the `new_unit_of_measurement_id`
  // field empty (not ID with only zeros), but provide
  //`new_unit_of_measurement_id` string in the field mask.
  volue.mesh.grpc.type.Guid new_unit_of_measurement_id = 5;
}

message UpdateTimeseriesResourceResponse {
}


message AttributePair {
  // A time series attribute name.
  string source_attribute_name = 1;

  // The target can either be a direct name or a search/navigation spec.
  oneof target_attribute {
    // Use name when the target attribute is found by internal lookup on target
    // object.
    string target_attribute_name = 2;

    // Use search when the target attribute is found by general search from
    // target object. To accept a search based mapping, the result of the
    // search must be 1 time series attribute. The attribute search expression
    // may contain a macro named $ObjName to make search more specific.
    // The value of the macro is associated with the source object name.
    // By using this macro it is possible to reach out to target series in
    // a more generic way. Example:
    //   ../../*[.Type=Asset&&.Name=$ObjName&&...Name=C3].Ts1
    //
    // When at a source object having a name CA1, the search string will be
    // expanded to ../../*[.Type=Asset&&.Name=CA1&&...Name=C3].Ts1
    // Because the structure of the source and target hierarchy normally is the
    // same, this will narrow the search.
    string target_attribute_search = 3;
  }
}
// Mapping details
message TypeAttributeMapping {

  // The Mesh object type name.
  // When specified, only time series that match this filter will be considered
  // for copy.
  string object_type_name = 1;

  // Mapping between time series source attribute name and target name.
  // Target name may be a search expression.
  repeated AttributePair attribute_mappings = 2;
}

message CopyTimeseriesBetweenObjectsRequest {
  volue.mesh.grpc.type.Guid session_id = 1;

  // If interval is not supplied, the request will do a tentative operation
  // which logs what time series will be copied if a valid interval is given.
  volue.mesh.grpc.type.UtcInterval interval = 2;

  // Identify the root object of the Source hierarchy (path or guid)
  volue.mesh.grpc.type.MeshId source = 3;
  // If scenario name is specified, the source series must be bound to
  // a scenario object. To categorize an object as a scenario object follow
  // a convention where:
  // a) The object itself has name == scenario_name
  // b) The owner object (OwnerElement) has a object type name ending with
  //    Scenario
  string scenario_name = 4;
  // Identify the root object of the Target hierarchy (path or guid).
  // In case attribute mapping is enabled the source and target may refer to
  // same object.
  volue.mesh.grpc.type.MeshId target = 5;

  // Optional
  // Defines which part of source hierarchy to copy and potentially also where
  // to copy. In case this mapping is not specified the operation copies
  // everything that matches general criteria. General criteria: source series
  // can provide values (ts binding or expression) and target series can be
  // persisted.
  repeated TypeAttributeMapping mappings = 6;
}

message CopyTimeseriesBetweenObjectsResponse {
  // Number of source series considered.
  int64 source_series_count = 1;

  // Number of target series considered.
  int64 target_series_count = 2;

  // The number of series that will be copied if input interval is defined.
  // When this value is > 0 the operations were successful.
  int64 match_series_count = 3;
}

// Request for creating new physical timeseries resources. All the fields are
// mandatory.
// See the documentation of the CreatePhysicalTimeseries RPC for more info.
message CreatePhysicalTimeseriesRequest {
  volue.mesh.grpc.type.Guid session_id = 1;

  string path = 2;

  string name = 3;

  volue.mesh.grpc.type.Curve curve_type = 4;

  volue.mesh.grpc.type.Resolution resolution = 5;

  volue.mesh.grpc.type.Guid unit_of_measurement_id = 6;
}
