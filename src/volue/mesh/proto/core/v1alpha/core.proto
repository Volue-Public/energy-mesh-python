syntax = "proto3";

package volue.mesh.grpc.core.v1alpha;

import "google/protobuf/empty.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";
import "volue/mesh/proto/type/resources.proto";


// Mesh server service
// -------------------------------
// The Mesh service is an API for interacting with a running Mesh server, also called just Mesh.
//
//
// Authentication
//
// When Mesh is configured to require authentication an access token is
// necessary for most calls. You can acquire an access token through Kerberos
// authentication as described above the `AuthenticateKerberos` method. Access
// tokens are passed in the `Authorization` metadata field of each RPC with the
// format `Bearer <access token>`.
//
// Many gRPC libraries provide call credential types that correctly pass the
// access token to the server, for example `grpc::AccessTokenCredentials` in C++.
// These mechanisms will generally take the bare access token (without `Bearer`),
// and create the `Bearer <access token>` string internally.
//
// Access tokens expire after an hour and should be refreshed before then.
// Getting a new token early, for example after half the expiration time, is
// recommended.
//
service MeshService {

  // Authenticate using Kerberos
  // -------------------------------
  // Perform a potentially multi-leg Kerberos authentication where the client
  // and the server sends Kerberos tickets back and forth until a complete
  // security context is established or an error occurs.

  // On success the final response from the server will contain a bearer token
  // that should be used as a token in calls that require authorization, as
  // well as the expiration time for that token.
  rpc AuthenticateKerberos(stream google.protobuf.BytesValue) returns (stream AuthenticateKerberosResponse) {}

  rpc AuthenticateFake(AuthenticateFakeRequest) returns (AuthenticateFakeResponse) {}

  // Revoke an access token received from `AuthenticateKerberos`, causing
  // it to become immediately unusable. If the RPC returns without error
  // the operation succeeded *or* the token does not exist.
  rpc RevokeAccessToken(google.protobuf.StringValue) returns (RevokeAccessTokenResponse) {}

  // Returns the identity that was used to create the access token authorizing
  // this call.
  rpc GetUserIdentity(google.protobuf.Empty) returns (UserIdentity) {}

  // Sessions
  // -------------------------------
  // To work with data inside a Mesh server you need to create a workspace which
  // is called a session. Here you can have changes and calculations pending which
  // won't be visible to other users of the Mesh server until you commit them.
  //

  // Start a Mesh session on the server, return the id of the session.
  rpc StartSession(google.protobuf.Empty) returns (volue.mesh.grpc.type.Guid) {}

  // Close a session on the Mesh server.
  rpc EndSession(volue.mesh.grpc.type.Guid) returns (EndSessionResponse) {}

  // Commit changes in a server session to permanent storage.
  rpc Commit(volue.mesh.grpc.type.Guid) returns (CommitResponse) {}

  // Rollback changes that are in the server's session but not in the database yet.
  rpc Rollback(volue.mesh.grpc.type.Guid) returns (RollbackResponse) {}

  // Timeseries
  // -------------------------------
  // In its simplest form a timeseries is just a table of timestamps, flags and values.
  // Timeseries can be organized and generated in different ways.
  // Some timeseries are retrieved 'as is' from the database where they are stored, while others
  // are generated using calculations which can be based on an arbitrary set of data.
  // Timeseries can be organized in a structure which resembles catalogs and thus can have a
  // path associated with it. They can also potentially be linked to a node in a Mesh model and with
  // that get a path that represents the nodes position in the Mesh model. More meta data like unit
  // of measurement, curve type and so on can also be linked to the timeseries.

  // Get a series of timestamps, flags and values.
  rpc ReadTimeseries(ReadTimeseriesRequest) returns (ReadTimeseriesResponse) {}

  // Write a series of timestamps, flags and values.
  rpc WriteTimeseries(WriteTimeseriesRequest) returns (WriteTimeseriesResponse) {}

  // Other timeseries might not be connected to a Mesh model at all, but instead be organized
  // in some sort of catalog structure.
  // This kind of metadata is called entry data.
  rpc GetTimeseriesEntry(GetTimeseriesEntryRequest) returns (TimeseriesEntry) {}

  // Update timeseries entry meta data
  rpc UpdateTimeseriesEntry(UpdateTimeseriesEntryRequest) returns (UpdateTimeseriesEntryResponse) {}

  // When a timeseries, either calculated or not, is linked to a node in a Mesh model,
  // some meta data associated with the Mesh model node can be retrieved.
  // This kind of metadata is called attribute data.
  rpc GetTimeseriesAttribute(GetTimeseriesAttributeRequest) returns (TimeseriesAttribute) {}

  // Search for timeseries attributes in a given physical model
  //
  // The search uses Mesh's query language, which is the same language that's
  // used in for example Nimbus.
  //
  // The result stream is not ordered in any particular way, and the caller
  // should not expect the ordering of search results to be stable.
  //
  // Returns an error if:
  //
  // - the session doesn't exist,
  // - the model doesn't exist,
  // - the start object doesn't exist, or
  // - the search query is invalid.
  //
  // If the search doesn't find any results an empty stream and an OK status
  // is returned.
  rpc SearchTimeseriesAttributes(SearchTimeseriesAttributesRequest) returns (stream TimeseriesAttribute) {}

  // Run ad-hoc calculation
  rpc RunCalculation(CalculationRequest) returns (CalculationResponse) {}

  // Get specific object from the model.
  rpc GetObject(GetObjectRequest) returns (Object) {}

  // Search for objects from the model.
  // The search uses Mesh's query language, which is the same language that's
  // used in for example Nimbus.
  //
  // The result stream is not ordered in any particular way, and the caller
  // should not expect the ordering of search results to be stable.
  //
  // If the search doesn't find any results an empty stream and an OK status
  // is returned.
  rpc SearchObjects(SearchObjectsRequest) returns (stream Object) {}

  // Create new object in the model.
  // In the first step user sets owner and name of the new object.
  // In case of success, the create operation returns OK status and newly
  // created object with all of the attributes set to default values.
  // Then the user may update the attributes with proper update attributes
  // RPCs, e.g.: `UpdateSimpleAttribute` or `UpdateTimeseriesAttribute`.
  // Note: Returned object has all attributes (no mask applied) and
  // `AttributeView::BASIC`.
  rpc CreateObject(CreateObjectRequest) returns (Object) {}

  // Update existing object in the model.
  // User may rename an object or change its owner.
  // To update object's attributes use proper update attributes RPCs,
  // e.g.: `UpdateSimpleAttribute` or `UpdateTimeseriesAttribute`.
  rpc UpdateObject(UpdateObjectRequest) returns (UpdateObjectResponse) {}

  // Delete existing object in the model.
  rpc DeleteObject(DeleteObjectRequest) returns (DeleteObjectResponse) {}

  // Get specific attribute from the model.
  rpc GetAttribute(GetAttributeRequest) returns (Attribute) {}

  // Search for attributes from the model.
  // The search uses Mesh's query language, which is the same language that's
  // used in for example Nimbus.
  //
  // The result stream is not ordered in any particular way, and the caller
  // should not expect the ordering of search results to be stable.
  //
  // If the search doesn't find any results an empty stream and an OK status
  // is returned.
  rpc SearchAttributes(SearchAttributesRequest) returns (stream Attribute) {}

  // Update value(s) of existing simple attribute in the model.
  // Simple attribute is a singular type or collection of the following types:
  // - double
  // - integer
  // - boolean
  // - string
  // - UTC time
  rpc UpdateSimpleAttribute(UpdateSimpleAttributeRequest) returns (UpdateSimpleAttributeResponse) {}

  // Update existing time series attribute in the model.
  rpc UpdateTimeseriesAttribute(UpdateTimeseriesAttributeRequest) returns (UpdateTimeseriesAttributeResponse) {}

  // Get the Mesh server version information.
  rpc GetVersion(google.protobuf.Empty) returns (VersionInfo) {}
}

message AuthenticateKerberosResponse {
  // The Kerberos ticket returned by the server's AcceptSecurityContext call.
  bytes kerberos_token = 1;

  // A base64 encoded access token.
  string bearer_token = 2;

  // The access token will become invalid at this time.
  google.protobuf.Duration token_duration = 3;
}

message AuthenticateFakeRequest {
  string display_name = 1;
  google.protobuf.Duration token_duration = 2;
  string internal = 15;
}

message AuthenticateFakeResponse {
  string bearer_token = 1;
  google.protobuf.Duration token_duration = 2;
}

message RevokeAccessTokenResponse {
  // currently empty
}

message UserIdentity {
  // A human readable name identifying this user. This name should not be
  // used as an unique identifier for the user as it may be identical
  // between users and change over time.
  string display_name = 1;

  // Security package name where the user identity came from.
  // It is not an unique identifier of the security package instance.
  string source = 2;

  // An identifier that uniquely identifies the user within given `source` instance, but
  // not necessarily globally. Combining `source` and `identifier` does not guarantee
  // to get globally unique identifier for the user as there may be different
  // Active Directories using the same security packages (`source`) with
  // duplicated user identifiers. However such situation is rather unlikely.
  string identifier = 3;
}

message EndSessionResponse {
  // currently empty
}

message CommitResponse {
  // currently empty
}

message RollbackResponse {
  // currently empty
}

message ReadTimeseriesRequest {
  // The server session ID
  volue.mesh.grpc.type.Guid session_id = 1;

  // The search can return more than one valid object.
  // In that case, the timeseries will be read for all
  // valid objects, for the requested interval.
  ObjectId object_id = 2;
  volue.mesh.grpc.type.UtcInterval interval = 3;

  // if we request points from a breakpoint series, the actual points
  // describing our interval, might be long before the actual interval.
  // Should we then return the actual point (outside our interval),
  // or a "fake"/virtual point inside our interval?
  // TODO: bool allow_virtual_points?
}

message ReadTimeseriesResponse {
  // A search expression may return several timeseries.
  repeated Timeseries timeseries = 1;
}

message WriteTimeseriesRequest {
  volue.mesh.grpc.type.Guid session_id = 1;

  // Must point to exactly one Timeseries
  // (entry, attribute or value)
  ObjectId object_id = 2;

  // The resolution of the points has to fit the stored timeseries.
  // Otherwise it will be rejected.
  Timeseries timeseries = 3;
}

message WriteTimeseriesResponse {
  // currently empty
}

message GetTimeseriesEntryRequest {
  // The server session ID
  volue.mesh.grpc.type.Guid session_id = 1;
  // Object for identifying a timeseries entry.
  TimeseriesEntryId entry_id = 2;
}

message UpdateTimeseriesEntryRequest {
  // ID of the Mesh server's session in which changes should be applied.
  volue.mesh.grpc.type.Guid session_id = 1;
  //
  TimeseriesEntryId entry_id = 2;

  // Only paths set in the field mask are updated.
  // (except complex types like Curve, those could be checked if are set)
  google.protobuf.FieldMask field_mask = 3;

  // All the following are optional.
  // -------
  // New path for entry.
  string new_path = 4;
  // New curve type of the timeseries.
  volue.mesh.grpc.type.Curve new_curve_type = 5;
  // New unit of measurement for the timeseries.
  string new_unit_of_measurement = 6;
}

message GetTimeseriesAttributeRequest {
  // The server session ID
  volue.mesh.grpc.type.Guid session_id = 1;
  //
  string model = 2;
  //
  AttributeId attribute_id = 3;
}

message UpdateTimeseriesEntryResponse {
  // currently empty
}

message SearchTimeseriesAttributesRequest {
   volue.mesh.grpc.type.Guid session_id = 1;
    // Name of the physical model in which to search.
    string model_name = 2;
    // Mesh searches always require a start point for the search.
    oneof start_object_oneof {
        // Where to start the search, in the form of a `name.attribute/name.attribute/name`
        // path. For example `Norway.has_WaterCourse/Orkla`.
        string start_object_path = 3;
        // Where to start the search, in the form of a GUID.
        volue.mesh.grpc.type.Guid start_object_guid = 4;
    }
    // Query in Mesh query language format.
    string query = 5;
}

message CalculationRequest {
    volue.mesh.grpc.type.Guid session_id = 1;
    string expression = 2;
    volue.mesh.grpc.type.UtcInterval interval = 3;
    ObjectId relative_to = 4;
}

message CalculationResponse {
    oneof calculation_result_oneof {
        ReadTimeseriesResponse timeseries_results = 1;  // not all fields in Timeseries result will be set (e.g. full_name, or timskey)
        NumericResults numeric_results = 2;
        StringResults string_results = 3;
    }
}

message GetObjectRequest {
  // The server session ID
  volue.mesh.grpc.type.Guid session_id = 1;

  // ID or path of object to be returned.
  MeshId object_id = 2;

  // Masks that define what attributes for the given object should be returned
  // in the response message.
  // If not set then all attributes will be returned.
  AttributesMasks attributes_masks = 3;

  // Defines what attribute information should be included in response.
  AttributeView attribute_view = 4;
}

message SearchObjectsRequest {
  // The server session ID
  volue.mesh.grpc.type.Guid session_id = 1;

  // Mesh searches always require a start point for the search.
  MeshId start_object_id = 2;

  // Query in Mesh query language format.
  string query = 3;

  // Masks that define what attributes for the given object should be returned
  // in the response message.
  // If not set then all attributes will be returned.
  AttributesMasks attributes_masks = 4;

  // Defines what attribute information should be included in response.
  AttributeView attribute_view = 5;
}

message CreateObjectRequest {
  // ID of the Mesh server's session in which changes should be applied.
  volue.mesh.grpc.type.Guid session_id = 1;

  // Name of the new object.
  string name = 2;

  // Owner of the new object.
  // Owner must be a relationship attribute of Object Collection type.
  // E.g.: for `SomePowerPlant1` object with path:
  //   - Model/SimpleThermalTestModel/ThermalComponent.ThermalPowerToPlantRef/SomePowerPlant1
  //   Owner will be the `ThermalPowerToPlantRef` attribute.
  MeshId owner_id = 3;
}

message UpdateObjectRequest {
  // ID of the Mesh server's session in which changes should be applied.
  volue.mesh.grpc.type.Guid session_id = 1;

  // Identifier of the object to be updated.
  MeshId object_id = 2;

  // Only paths set in the field mask are updated.
  google.protobuf.FieldMask field_mask = 3;

  // New name of the object.
  string new_name = 4;

  // New owner of the object.
  // Owner must be a relationship attribute of Object or Object Collection type.
  // E.g.: for `SomePowerPlant1` object with path:
  //   - Model/SimpleThermalTestModel/ThermalComponent.ThermalPowerToPlantRef/SomePowerPlant1
  //   Owner will be the `ThermalPowerToPlantRef` attribute.
  MeshId new_owner_id = 5;
}

message UpdateObjectResponse {
  // currently empty
}

message DeleteObjectRequest {
  // ID of the Mesh server's session in which changes should be applied.
  volue.mesh.grpc.type.Guid session_id = 1;

  // Object to be deleted.
  MeshId object_id = 2;

  // If set to true then all child objects (owned by the object to be deleted)
  // in the model will also be deleted.
  // Default value is false (default value for bool in proto3 is false).
  bool recursive_delete = 3;
}

message DeleteObjectResponse {
  // currently empty
}

message GetAttributeRequest {
  // The server session ID
  volue.mesh.grpc.type.Guid session_id = 1;

  // ID or path of attribute to be returned.
  MeshId attribute_id = 2;

  // Defines what attribute information should be included in response.
  AttributeView attribute_view = 3;
}

message SearchAttributesRequest {
  // The server session ID
  volue.mesh.grpc.type.Guid session_id = 1;

  // Mesh searches always require a start point for the search.
  MeshId start_object_id = 2;

  // Query in Mesh query language format.
  string query = 3;

  // Defines what attribute information should be included in response.
  AttributeView attribute_view = 4;
}

message UpdateSimpleAttributeRequest {
  // ID of the Mesh server's session in which changes should be applied.
  volue.mesh.grpc.type.Guid session_id = 1;

  MeshId attribute_id = 2;

  // Simple attribute value example:
  //   To update a string attribute value set
  //      new_singular_value.string_value = 'new_value'
  //   To update a string attribute collection values set
  //      new_collection_values[0].string_value = 'new_value_1'
  //      new_collection_values[1].string_value = 'new_value_2'
  //      new_collection_values[2].string_value = 'new_value_3'
  //
  // Note: 
  // To remove all existing values from an attribute collection
  // just set session_id and attribute_id of an attribute collection
  // type and leave the new_collection_values empty.

  // Singular type can be e.g.: double attribute
  AttributeValue new_singular_value = 3;
  // Collection of types can be e.g.: collection of double attributes
  repeated AttributeValue new_collection_values = 4;
}

message UpdateSimpleAttributeResponse {
  // currently empty
}

message UpdateTimeseriesAttributeRequest {
  // ID of the Mesh server's session in which changes should be applied.
  volue.mesh.grpc.type.Guid session_id = 1;

  MeshId attribute_id = 2;

  // An array containing field names to be updated.
  // For example to update a time series attribute local expression and
  // connected time series resource:
  //   field_mask = ['new_timeseries_resource_key', 'new_local_expression']
  //   new_timeseries_resource_key = 100
  //   new_local_expression = 'new local expression'
  google.protobuf.FieldMask field_mask = 3;

  // Time series key of the time series resource to be connected to
  // the given time series attribute.
  // Note:
  // To disconnect time series attribute from already connected time
  // series resource set `new_timeseries_resource_key` to 0.
  int64 new_timeseries_resource_key = 4;
  string new_local_expression = 5;
}

message UpdateTimeseriesAttributeResponse {
  // currently empty
}

// Contains one or more ways to uniquely identify an object.
message ObjectId {
  optional int64 timskey = 1;
  optional volue.mesh.grpc.type.Guid guid = 2;
  optional string full_name = 3;
}

message Timeseries {
  // GUID of the timeseries entry.
  ObjectId object_id = 1;

  // Resolution/spacing for this timeseries.
  volue.mesh.grpc.type.Resolution resolution = 2;

  // Time interval for this timeseries.
  volue.mesh.grpc.type.UtcInterval interval = 3;

  // Data contains an Apache Arrow byte representation of the timeseries points.
  // Stored in the following columns:
  // 0: (uint64) utc_time
  // 1: (uint32) flags
  // 2: (double) value
  bytes data = 4;
}

message AttributeId {
  oneof id_oneof {
    volue.mesh.grpc.type.Guid id = 1;
    string path = 2;
  }
}

message TimeseriesEntryId {
  // A timeseries entry can be uniquely identified by one the following:
  oneof id_oneof {
    // GUID of the timeseries entry.
    volue.mesh.grpc.type.Guid guid = 1;
    // Path associated with the entry.
    string path = 2;
    // The timeseries key (timskey) of the timeseries.
    int64 timeseries_key = 3;
  }
}

message TimeseriesEntry {
  volue.mesh.grpc.type.Guid id = 1;
  // 0 if local session series
  int64 timeseries_key = 2;
  // path/tscode???
  string path = 3;
  // Local session series if true
  bool temporary = 4;
  volue.mesh.grpc.type.Curve curve_type = 5;
  volue.mesh.grpc.type.Resolution resolution = 6;
  string unit_of_measurement = 7;
}

// Information about physical or virtual time series.
message TimeseriesResource {
  // Unique identifier for physical or virtual time series.
  // Set to 0 if it is a local session time series.
  // This is the only field that could be used for updating 
  // time series attribute with new time series resource.
  int64 timeseries_key = 1;

  // [OUTPUT_ONLY]
  string path = 2;

  // [OUTPUT_ONLY]
  string name = 3;

  // Set to true if it is a local session time series.
  // [OUTPUT_ONLY]
  bool temporary = 4;

  // [OUTPUT_ONLY]
  volue.mesh.grpc.type.Curve curve_type = 5;

  // [OUTPUT_ONLY]
  volue.mesh.grpc.type.Resolution resolution = 6;

  // [OUTPUT_ONLY]
  string unit_of_measurement = 7;
}

message TimeseriesAttribute {
  volue.mesh.grpc.type.Guid id = 1;
  // Model path.
  string path = 2;
  // A timeseries entry if the attribute refers to one.
  TimeseriesEntry entry = 3;
  // A local calculation expression if one is set on this physical node.
  string local_expression = 4;
  // Template expression, inherited from the repo type if set.
  string template_expression = 5;
}

message NumericResults {
    repeated double value = 1;
}

message StringResults {
    repeated string value = 1;
}

// Version information for the Mesh server.
message VersionInfo {
  string version = 1;
  // Friendly name of the Mesh server, e.g.: Volue Mesh Server
  string name = 2;
}

// Every field uniquely identifies a Mesh Object, Attribute or other types.
// For request messages it is enough to provide just one of the fields:
// ID, path or time series key.
// Note: time series key is applicable only for resource time series: physical or virtual.
message MeshId {
  optional volue.mesh.grpc.type.Guid id = 1;
  optional string path = 2;
  optional int64 timeseries_key = 3;
}

// Defines what attributes need to be returned in response message.
message AttributesMasks {
  // Attribute name uniquely identifies attribute within given object.
  // If set then only attributes set in the field mask are read.
  // If any other mask: tag or namespace or `return_no_attributes`
  // flag is also set then an error will be returned.
  // The attribute name provided in the mask must be equal to
  // the actual attribute name in the model.
  // Note: Regular expressions are not supported.
  // See examples below for more details.
  google.protobuf.FieldMask name_mask = 1;

  // Each attribute can have zero, one or more tags.
  // If the tag mask is set then only attributes with
  // at least one tag set in the field mask are read.
  // If multiple tags are provided then all attributes having
  // at least one of them are returned (logical OR).
  // If name mask or `return_no_attributes` flag is also set
  // then an error will be returned.
  // It is allowed to have both: tag mask and namespace mask set.
  // Note: Regular expressions are not supported.
  // See examples below for more details.
  google.protobuf.FieldMask tag_mask = 2;

  // Each attribute can have zero, one or more namespaces.
  // If the namespace mask is set then only attributes with
  // at least one namespace set in the field mask are read.
  // If multiple namespaces are provided in the mask then all
  // attributes having at least one of them are returned (logical OR).
  // Namespace mask does not accept entries with namespaces
  // concatenated with dots '.'. Each namespace mask entry must
  // be a separate namespace.
  // If name mask or `return_no_attributes` flag is also set
  // then an error will be returned.
  // It is allowed to have both: tag mask and namespace mask set.
  // Note: Regular expressions are not supported.
  // See examples below for more details.
  google.protobuf.FieldMask namespace_mask = 3;

  // If set to true then no attributes will be returned.
  // If any mask: name, tag or namespace is also set
  // then an error will be returned.
  // Default value is false (default value for bool in proto3 is false).
  bool return_no_attributes = 4;

  // Multiple attributes may have the same tag or namespace.
  // If both: tag_mask and namespace_masks are provided then only attributes
  // that meet both criteria are returned (intersection/logical AND).
  //
  // Example 1:
  //    Arg:      `name_mask` is set to "Price,Volume,Production"
  //    Response: All attributes with names "Price", "Volume" or "Production"
  //              will be returned.
  //
  // Example 2:
  //    Arg:      `tag_mask` is set to "ProductionAttributes,LocationAttributes"
  //    Response: All attributes with tag name "ProductionAttributes" or
  //              "LocationAttributes" will be returned.
  //    Note:     If attributes A1, A2 have tag "ProductionAttributes" and A3
  //              has "LocationAttributes" then all three attributes
  //              (A1, A2 and A3) will be returned.
  //              Exactly the same rules apply to `namespace_mask`.
  //
  // Example 3:
  //    Arg:      `namespace_mask` is set to "Hydro,Wind".
  //    Response: All attributes with namespace "Hydro" or "Wind" will be returned.
  //    Note:     Suppose there are the following attributes:
  //              - A1 (namespace "EnergySystem.Hydro")
  //              - A2 (namespace "EnergySystem.Wind")
  //              - A3 (namespace "EnergySystem.Carbon")
  //              - A4 (namespace "EnergySystem.Hydro.Small")
  //              - A5 (namespace "Hydro.Normal")
  //              In this case attributes A1, A2, A4 and A5 will be returned.
  //
  // Example 4:
  //    Arg:      `tag_mask` is set to "ProductionAttributes",
  //              `namespace_mask` is set to "Hydro,Wind".
  //    Response: All attributes with tag name "ProductionAttributes" and
  //              namespace "Hydro" or "Wind" will be returned.
  //    Note:     Suppose there are the following attributes:
  //              - A1 (tag "ProductionAttributes", namespace "EnergySystem.Hydro")
  //              - A2 (tag "ProductionAttributes", namespace "EnergySystem.Wind")
  //              - A3 (tag "ProductionAttributes", namespace "EnergySystem.Carbon")
  //              - A4 (tag "LocationAttributes", namespace "EnergySystem.Hydro")
  //              - A5 (tag "LocationAttributes", namespace "EnergySystem.Wind")
  //              In this case attributes A1 and A2 will be returned.
  //
  //  Note: If no masks are provided then all attributes will be returned.
}

message Object {
  volue.mesh.grpc.type.Guid id = 1;
  string path = 2;
  string name = 3;
  string type_name = 4;

  // Relation attribute owning given object, e.g.:
  //   For `SomePowerPlant1` object with path:
  //   - Model/SimpleThermalTestModel/ThermalComponent.ThermalPowerToPlantRef/SomePowerPlant1
  //   Owner will be the `ThermalPowerToPlantRef` attribute.
  MeshId owner_id = 5;
  repeated Attribute attributes = 6;
}

message Attribute {
  // ID of the attribute in the model.
  volue.mesh.grpc.type.Guid id = 1;

  string path = 2;
  string name = 3;
  AttributeDefinition definition = 4;

  // Singular type can be e.g.: double attribute or time series attribute
  AttributeValue singular_value = 5;
  // Collection of types can be e.g.: collection of double attributes
  repeated AttributeValue collection_values = 6;
}

message AttributeValue {
  oneof value_oneof {
    int64 int_value = 1;
    double double_value = 2;
    bool boolean_value = 3;
    string string_value = 4;
    google.protobuf.Timestamp utc_time_value = 5;

    TimeseriesAttributeValue timeseries_value = 6;
    RatingCurveAttributeValue rating_curve_value = 7;
    XYtableAttributeValue xy_table_value = 8;
  }
}

message TimeseriesAttributeValue {
  // Physical or virtual time series identifier from resources
  // if the attribute refers to one.
  // To disconnect time series attribute from already connected time
  // series resource set `new_timeseries_resource_key` to 0 in the
  // `UpdateTimeseriesAttribute` RPC.
  // To update curve type or resolution use `UpdateTimeseriesResource` RPC.
  TimeseriesResource time_series_resource = 1;

  // Expression that is actually used by the time series attribute.
  // It uses local expression if set, otherwise template expression
  // (defined in TimeseriesAttributeDefinition) will be used.
  // When updating expression the new value will always be assigned
  // to local expression.
  // Note: Local expression is set on the object level in the model.
  string expression = 2;

  // Flag indicating expression that is actually used is a local expression.
  // [OUTPUT_ONLY]
  bool is_local_expression = 3;
}

message RatingCurveAttributeValue {
  // TODO: define
}

// TODO: XY or XYZ?
message XYtableAttributeValue {
  // TODO: define
}

message AttributeDefinition {
  volue.mesh.grpc.type.Guid id = 1;
  string path = 2;
  string name = 3;

  string description = 4;
  repeated string tags = 5;

  // If an attribute has more than one namespace,
  // they are concatenated with dots '.', e.g.:
  //   namespace1.namespace2
  string name_space = 6;
  string value_type = 7;

  // Specifies minimum and maximum size of a collection of attributes.
  // Minimum and maximum cardinality applies only to a collection of attributes
  // e.g.: collection of double attributes
  // For singular types both minimum and maximum cardinality is set to 1.
  int64 minimum_cardinality = 8;
  int64 maximum_cardinality = 9;

  oneof definition_type_oneof {
    Int64AttributeDefinition int_definition = 10;
    DoubleAttributeDefinition double_definition = 11;
    BooleanAttributeDefinition boolean_definition = 12;
    StringAttributeDefinition string_definition = 13;
    UtcTimeAttributeDefinition utc_time_definition = 14;

    TimeseriesAttributeDefinition timeseries_definition = 15;
    RatingCurveAttributeDefinition rating_curve_definition = 16;
    XYtableAttributeDefinition xy_table_definition = 17;
    RelationshipAttributeDefinition relationship_definition = 18;
  }
}

message Int64AttributeDefinition {
  int64 default_value = 1;
  int64 minimum_value = 2;
  int64 maximum_value = 3;
  string unit_of_measurement = 4;
}

message DoubleAttributeDefinition {
  double default_value = 1;
  double minimum_value = 2;
  double maximum_value = 3;
  string unit_of_measurement = 4;
}

message BooleanAttributeDefinition {
  bool default_value = 1;
}

message StringAttributeDefinition {
  string default_value = 1;
}

message UtcTimeAttributeDefinition {
  string default_value = 1;
  string minimum_value = 2;
  string maximum_value = 3;
}

message TimeseriesAttributeDefinition {
  string template_expression = 1;
  string unit_of_measurement = 2;
}

message RatingCurveAttributeDefinition {
  // TODO: define
}

// TODO: XY or XYZ?
message XYtableAttributeDefinition {
  // TODO: define
}

message RelationshipAttributeDefinition {
  string object_type = 1;
}

enum AttributeView {
  // Not specified, equivalent to BASIC.
  OBJECT_VIEW_UNSPECIFIED = 0;

  // Response will include attribute's ID, name, path and value(s).
  // The default value.
  BASIC = 1;

  // Response will include attribute's ID, name, path, value(s) and
  // complete attribute definition.
  FULL = 2;
}
