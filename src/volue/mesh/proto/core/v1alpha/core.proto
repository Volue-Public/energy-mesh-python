syntax = "proto3";

package volue.mesh.grpc.core.v1alpha;

import "google/protobuf/empty.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";
import "google/protobuf/struct.proto";
import "volue/mesh/proto/type/resources.proto";


// Mesh server service
// -------------------------------
// The Mesh service is an API for interacting with a running Mesh server, also called just Mesh.
//
//
// Authentication
//
// When Mesh is configured to require authentication an access token is
// necessary for most calls. You can acquire an access token through Kerberos
// authentication as described above the `AuthenticateKerberos` method. Access
// tokens are passed in the `Authorization` metadata field of each RPC with the
// format `Bearer <access token>`.
//
// Many gRPC libraries provide call credential types that correctly pass the
// access token to the server, for example `grpc::AccessTokenCredentials` in C++.
// These mechanisms will generally take the bare access token (without `Bearer`),
// and create the `Bearer <access token>` string internally.
//
// Access tokens expire after an hour and should be refreshed before then.
// Getting a new token early, for example after half the expiration time, is
// recommended.
//
service MeshService {

  // Authenticate using Kerberos
  // -------------------------------
  // Perform a potentially multi-leg Kerberos authentication where the client
  // and the server sends Kerberos tickets back and forth until a complete
  // security context is established or an error occurs.

  // On success the final response from the server will contain a bearer token
  // that should be used as a token in calls that require authorization, as
  // well as the expiration time for that token.
  rpc AuthenticateKerberos(stream google.protobuf.BytesValue) returns (stream AuthenticateKerberosResponse) {}

  rpc AuthenticateFake(AuthenticateFakeRequest) returns (AuthenticateFakeResponse) {}

  // Revoke an access token received from `AuthenticateKerberos`, causing
  // it to become immediately unusable. If the RPC returns without error
  // the operation succeeded *or* the token does not exist.
  rpc RevokeAccessToken(google.protobuf.StringValue) returns (RevokeAccessTokenResponse) {}

  // Returns the identity that was used to create the access token authorizing
  // this call.
  rpc GetUserIdentity(google.protobuf.Empty) returns (UserIdentity) {}

  // Sessions
  // -------------------------------
  // To work with data inside a Mesh server you need to create a workspace which
  // is called a session. Here you can have changes and calculations pending which
  // won't be visible to other users of the Mesh server until you commit them.
  //

  // Start a Mesh session on the server, return the id of the session.
  rpc StartSession(google.protobuf.Empty) returns (volue.mesh.grpc.type.Guid) {}

  // Close a session on the Mesh server.
  rpc EndSession(volue.mesh.grpc.type.Guid) returns (EndSessionResponse) {}

  // Commit changes in a server session to permanent storage.
  rpc Commit(volue.mesh.grpc.type.Guid) returns (CommitResponse) {}

  // Rollback changes that are in the server's session but not in the database yet.
  rpc Rollback(volue.mesh.grpc.type.Guid) returns (RollbackResponse) {}

  rpc ExtendSession(volue.mesh.grpc.type.Guid) returns (ExtendSessionResponse) {}

  // Timeseries
  // -------------------------------
  // In its simplest form a timeseries is just a table of timestamps, flags and values.
  // Timeseries can be organized and generated in different ways.
  // Some timeseries are retrieved 'as is' from the database where they are stored, while others
  // are generated using calculations which can be based on an arbitrary set of data.
  // Timeseries can be organized in a structure which resembles catalogs and thus can have a
  // path associated with it. They can also potentially be linked to a node in a Mesh model and with
  // that get a path that represents the nodes position in the Mesh model. More meta data like unit
  // of measurement, curve type and so on can also be linked to the timeseries.

  // Get a series of timestamps, flags and values.
  rpc ReadTimeseries(ReadTimeseriesRequest) returns (ReadTimeseriesResponse) {}

  rpc ReadTimeseriesStream(ReadTimeseriesStreamRequest) returns (stream ReadTimeseriesResponse) {}

  // Write a series of timestamps, flags and values.
  rpc WriteTimeseries(WriteTimeseriesRequest) returns (WriteTimeseriesResponse) {}

  // Run ad-hoc calculation
  rpc RunCalculation(CalculationRequest) returns (CalculationResponse) {}

  // List all models.
  rpc ListModels(ListModelsRequest) returns (ListModelsResponse) {}

  // Get specific object from the model.
  rpc GetObject(GetObjectRequest) returns (Object) {}

  // Search for objects from the model.
  // The search uses Mesh's query language, which is the same language that's
  // used in for example Nimbus.
  //
  // The result stream is not ordered in any particular way, and the caller
  // should not expect the ordering of search results to be stable.
  //
  // If the search doesn't find any results an empty stream and an OK status
  // is returned.
  rpc SearchObjects(SearchObjectsRequest) returns (stream Object) {}

  // Create new object in the model.
  // In the first step user sets owner and name of the new object.
  // In case of success, the create operation returns OK status and newly
  // created object with all of the attributes set to default values.
  // Then the user may update the attributes with proper update attributes
  // RPCs, e.g.: `UpdateSimpleAttribute` or `UpdateTimeseriesAttribute`.
  // Note: Returned object has all attributes (no mask applied) and
  // `AttributeView::BASIC`.
  rpc CreateObject(CreateObjectRequest) returns (Object) {}

  // Update existing object in the model.
  // User may rename an object or change its owner.
  // To update object's attributes use proper update attributes RPCs,
  // e.g.: `UpdateSimpleAttribute` or `UpdateTimeseriesAttribute`.
  rpc UpdateObject(UpdateObjectRequest) returns (UpdateObjectResponse) {}

  // Delete existing object in the model.
  rpc DeleteObject(DeleteObjectRequest) returns (DeleteObjectResponse) {}

  // Get specific attribute from the model.
  rpc GetAttribute(GetAttributeRequest) returns (Attribute) {}

  // Search for attributes from the model.
  // The search uses Mesh's query language, which is the same language that's
  // used in for example Nimbus.
  //
  // The result stream is not ordered in any particular way, and the caller
  // should not expect the ordering of search results to be stable.
  //
  // If the search doesn't find any results an empty stream and an OK status
  // is returned.
  rpc SearchAttributes(SearchAttributesRequest) returns (stream Attribute) {}

  // Update value(s) of existing simple attribute in the model.
  // Simple attribute is a singular type or collection of the following types:
  // - double
  // - integer
  // - boolean
  // - string
  // - UTC time
  rpc UpdateSimpleAttribute(UpdateSimpleAttributeRequest) returns (UpdateSimpleAttributeResponse) {}

  // Update existing time series attribute in the model.
  rpc UpdateTimeseriesAttribute(UpdateTimeseriesAttributeRequest) returns (UpdateTimeseriesAttributeResponse) {}

  // Update existing one-to-one or one-to-many link relation (non-versioned)
  // attributes in the model.
  rpc UpdateLinkRelationAttribute(UpdateLinkRelationAttributeRequest) returns (UpdateLinkRelationAttributeResponse) {}

  // Update existing versioned one-to-one link relation attribute in the model.
  rpc UpdateVersionedLinkRelationAttribute(UpdateVersionedLinkRelationAttributeRequest) returns (UpdateVersionedLinkRelationAttributeResponse) {}

  // Get time series resource.
  // A time series resource:
  // - can be either physical or virtual time series
  // - can be connected to time series attributes.
  // - is identified by time series key or path within Resource catalog
  //
  // Physical time series has data (timestamps, values and flags) and
  // meta data (e.g.: curve type, resolution, etc.).
  // Virtual time series has meta data but instead of timestamps, values and
  // flags it has defined an expression to calculate time series data
  // (similar to calculation time series) but is stored in the resources.
  rpc GetTimeseriesResource(GetTimeseriesResourceRequest) returns (TimeseriesResource) {}

  // Update existing time series resource.
  rpc UpdateTimeseriesResource(UpdateTimeseriesResourceRequest) returns (UpdateTimeseriesResourceResponse) {}

  // Get the Mesh server version information.
  rpc GetVersion(google.protobuf.Empty) returns (VersionInfo) {}

  // Get the Mesh server health information. 
  // This function is not stable. Both signature and response content are subjects to change
  rpc GetHealthStatus(google.protobuf.Empty) returns (google.protobuf.Struct) {}

  // Get the Mesh server configuration. 
  // This function is not stable. Both signature and response content are subjects to change
  rpc GetConfiguration(google.protobuf.Empty) returns (google.protobuf.Struct) {}

  // Get zero or more `XySet`s from an XY-set attribute (`XYSetAttribute`) or
  // a versioned XY-set attribute (`XYZSeriesAttribute`). See `GetXySetsRequest`
  // for more information.
  rpc GetXySets(GetXySetsRequest) returns (GetXySetsResponse) {}

  // Create, update, and/or delete `XySet`s in an XY-set attribute
  // (`XYZAttribute`) or a versioned XY-set attribute (`XYZSeriesAttribute`).
  // See `UpdateXySetsRequest` for more information.
  rpc UpdateXySets(UpdateXySetsRequest) returns (UpdateXySetsResponse) {}

  // Get rating curve version(s) from a rating curve attribute
  // (`RatingCurveAttribute`).
  // See `GetRatingCurveVersionsRequest` for more information.
  rpc GetRatingCurveVersions(GetRatingCurveVersionsRequest) returns (GetRatingCurveVersionsResponse) {}

  // Create, update, and/or delete rating curve versions in a rating curve
  // attribute (`RatingCurveAttribute`).
  // See `UpdateRatingCurveVersionsRequest` for more information.
  rpc UpdateRatingCurveVersions(UpdateRatingCurveVersionsRequest) returns (UpdateRatingCurveVersionsResponse) {}

  // Get the currently set log level threshold
  rpc GetLogLevel(google.protobuf.Empty) returns (GetLogLevelResponse) {}

  // Change the log level threshold.
  rpc UpdateLogLevel(UpdateLogLevelRequest) returns (UpdateLogLevelResponse) {}

  // Copy time series from one part of Mesh model to another part of the model.
  // This method copies time series values from a set of time series (source) to another set of time series (target).
  // The input defines the root nodes of source hierarchy and target hierarchy.
  // In case these root nodes are different, the match between source series and target series is 
  // done by comparison of relative path to series attribute in source and target hierarchy.
  //
  // The function supports a mapping description that enables these operations:
  // - Copy to *another* attribute on the same object as the source series.
  // - Copy to *another* attribute on the matching object in the target hierarchy.
  // - Copy time series from a source hierarchy to a target identified by a general search/navigation spec on the mapping definition.
  //
  // In case mapping is enabled, the root nodes for source and target may be the same.
  rpc CopyTimeseriesBetweenObjects(CopyTimeseriesBetweenObjectsRequest) returns (CopyTimeseriesBetweenObjectsResponse) {}

  // Resources part of Mesh structure is not bound to a specific model definition or model.
  // It is organized by hierarchies of catalogs, like a file system. 
  // A catalog may contain different type of resource objects. The most common types are Timeseries, Binary files and Text files
  // This interface targets the Text files and provides functions to Read/Write/List text resources.

  rpc ListTextResources(ListTextResourcesRequest) returns (ListTextResourcesResponse) {}
  rpc GetTextResource(GetTextResourceRequest) returns (GetTextResourceResponse) {}
  rpc WriteTextResource(WriteTextResourceRequest) returns (WriteTextResourceResponse) {}

}

message AuthenticateKerberosResponse {
  // The Kerberos ticket returned by the server's AcceptSecurityContext call.
  bytes kerberos_token = 1;

  // A base64 encoded access token.
  string bearer_token = 2;

  // The access token will become invalid at this time.
  google.protobuf.Duration token_duration = 3;
}

message AuthenticateFakeRequest {
  string display_name = 1;
  google.protobuf.Duration token_duration = 2;
  string internal = 15;
}

message AuthenticateFakeResponse {
  string bearer_token = 1;
  google.protobuf.Duration token_duration = 2;
}

message RevokeAccessTokenResponse {}

message UserIdentity {
  // A human readable name identifying this user. This name should not be
  // used as an unique identifier for the user as it may be identical
  // between users and change over time.
  string display_name = 1;

  // Security package name where the user identity came from.
  // It is not an unique identifier of the security package instance.
  string source = 2;

  // An identifier that uniquely identifies the user within given `source` instance, but
  // not necessarily globally. Combining `source` and `identifier` does not guarantee
  // to get globally unique identifier for the user as there may be different
  // Active Directories using the same security packages (`source`) with
  // duplicated user identifiers. However such situation is rather unlikely.
  string identifier = 3;
}

message EndSessionResponse {}

message ExtendSessionResponse {
    google.protobuf.Duration expires_in = 1;
}

message CommitResponse {}

message RollbackResponse {}

message ReadTimeseriesRequest {
  // The server session ID
  volue.mesh.grpc.type.Guid session_id = 1;

  MeshId timeseries_id = 2;
  volue.mesh.grpc.type.UtcInterval interval = 3;

  // if we request points from a breakpoint series, the actual points
  // describing our interval, might be long before the actual interval.
  // Should we then return the actual point (outside our interval),
  // or a "fake"/virtual point inside our interval?
  // TODO: bool allow_virtual_points?
}

message ReadTimeseriesStreamRequest{
  // The server session ID
  volue.mesh.grpc.type.Guid session_id = 1;

  repeated MeshId timeseries_id = 2;
  volue.mesh.grpc.type.UtcInterval interval = 3;
}

message ReadTimeseriesResponse {
  repeated Timeseries timeseries = 1;
}

message WriteTimeseriesRequest {
  volue.mesh.grpc.type.Guid session_id = 1;

  // Time series must point to exactly one time series
  // - attribute or source (pointed by path or ID)
  // - physical or virtual (pointed by time series key)
  // The resolution of the points has to fit the stored time series.
  // Otherwise it will be rejected.
  Timeseries timeseries = 2;
}

message WriteTimeseriesResponse {}

message CalculationRequest {
    volue.mesh.grpc.type.Guid session_id = 1;
    string expression = 2;
    volue.mesh.grpc.type.UtcInterval interval = 3;
    MeshId relative_to = 4;
}

message CalculationResponse {
    oneof calculation_result_oneof {
        ReadTimeseriesResponse timeseries_results = 1;  // not all fields in Timeseries result will be set (e.g. full_name, or timskey)
        NumericResults numeric_results = 2;
        StringResults string_results = 3;
    }
}

message ListModelsRequest {
  // The server session ID.
  volue.mesh.grpc.type.Guid session_id = 1;
}

message ListModelsResponse {
  repeated Object models = 1;
}

message GetObjectRequest {
  // The server session ID
  volue.mesh.grpc.type.Guid session_id = 1;

  // ID or path of object to be returned.
  MeshId object_id = 2;

  // Masks that define what attributes for the given object should be returned
  // in the response message.
  // If not set then all attributes will be returned.
  AttributesMasks attributes_masks = 3;

  // Defines what attribute information should be included in response.
  AttributeView attribute_view = 4;
}

message SearchObjectsRequest {
  // The server session ID
  volue.mesh.grpc.type.Guid session_id = 1;

  // Mesh searches always require a start point for the search.
  MeshId start_object_id = 2;

  // Query in Mesh query language format.
  string query = 3;

  // Masks that define what attributes for the given object should be returned
  // in the response message.
  // If not set then all attributes will be returned.
  AttributesMasks attributes_masks = 4;

  // Defines what attribute information should be included in response.
  AttributeView attribute_view = 5;
}

message CreateObjectRequest {
  // ID of the Mesh server's session in which changes should be applied.
  volue.mesh.grpc.type.Guid session_id = 1;

  // Name of the new object.
  string name = 2;

  // Owner of the new object.
  // Owner must be an ownership relation attribute.
  // E.g.: for `SomePowerPlant1` object with path:
  //   - Model/SimpleThermalTestModel/ThermalComponent.ThermalPowerToPlantRef/SomePowerPlant1
  //   Owner will be the `ThermalPowerToPlantRef` attribute.
  MeshId owner_id = 3;
}

message UpdateObjectRequest {
  // ID of the Mesh server's session in which changes should be applied.
  volue.mesh.grpc.type.Guid session_id = 1;

  // Identifier of the object to be updated.
  MeshId object_id = 2;

  // Only paths set in the field mask are updated.
  google.protobuf.FieldMask field_mask = 3;

  // New name of the object.
  string new_name = 4;

  // New owner of the object.
  // Owner must be an ownership relation attribute of Object or Object
  // Collection type.
  // E.g.: for `SomePowerPlant1` object with path:
  //   - Model/SimpleThermalTestModel/ThermalComponent.ThermalPowerToPlantRef/SomePowerPlant1
  //   Owner will be the `ThermalPowerToPlantRef` attribute.
  MeshId new_owner_id = 5;
}

message UpdateObjectResponse {}

message DeleteObjectRequest {
  // ID of the Mesh server's session in which changes should be applied.
  volue.mesh.grpc.type.Guid session_id = 1;

  // Object to be deleted.
  MeshId object_id = 2;

  // If set to true then all child objects (owned by the object to be deleted)
  // in the model will also be deleted.
  // Default value is false (default value for bool in proto3 is false).
  bool recursive_delete = 3;
}

message DeleteObjectResponse {}

message GetAttributeRequest {
  // The server session ID
  volue.mesh.grpc.type.Guid session_id = 1;

  // ID or path of attribute to be returned.
  MeshId attribute_id = 2;

  // Defines what attribute information should be included in response.
  AttributeView attribute_view = 3;
}

message SearchAttributesRequest {
  // The server session ID
  volue.mesh.grpc.type.Guid session_id = 1;

  // Mesh searches always require a start point for the search.
  MeshId start_object_id = 2;

  // Query in Mesh query language format.
  string query = 3;

  // Defines what attribute information should be included in response.
  AttributeView attribute_view = 4;
}

message UpdateSimpleAttributeRequest {
  // ID of the Mesh server's session in which changes should be applied.
  volue.mesh.grpc.type.Guid session_id = 1;

  MeshId attribute_id = 2;

  // Simple attribute value example:
  //   To update a string attribute value set
  //      new_singular_value.string_value = 'new_value'
  //   To update a string attribute collection values set
  //      new_collection_values[0].string_value = 'new_value_1'
  //      new_collection_values[1].string_value = 'new_value_2'
  //      new_collection_values[2].string_value = 'new_value_3'
  //
  // Note: 
  // To remove all existing values from an attribute collection
  // just set session_id and attribute_id of an attribute collection
  // type and leave the new_collection_values empty.

  // Singular type can be e.g.: double attribute
  AttributeValue new_singular_value = 3;
  // Collection of types can be e.g.: collection of double attributes
  repeated AttributeValue new_collection_values = 4;
}

message UpdateSimpleAttributeResponse {}

message UpdateTimeseriesAttributeRequest {
  // ID of the Mesh server's session in which changes should be applied.
  volue.mesh.grpc.type.Guid session_id = 1;

  MeshId attribute_id = 2;

  // An array containing field names to be updated.
  // For example to update a time series attribute local expression and
  // connected time series resource:
  //   field_mask = ['new_timeseries_resource_key', 'new_local_expression']
  //   new_timeseries_resource_key = 100
  //   new_local_expression = 'new local expression'
  google.protobuf.FieldMask field_mask = 3;

  // Time series key of the time series resource to be connected to
  // the given time series attribute.
  // Note:
  // To disconnect time series attribute from already connected time
  // series resource set `new_timeseries_resource_key` to 0.
  int64 new_timeseries_resource_key = 4;
  string new_local_expression = 5;
}

message UpdateTimeseriesAttributeResponse {}

// Update request message for one-to-one link relation and one-to-many link
// relation attributes.
message UpdateLinkRelationAttributeRequest {
  // ID of the Mesh server's session in which changes should be applied.
  volue.mesh.grpc.type.Guid session_id = 1;

  // One-to-one link relation attribute (`ReferenceAttribute`) or one-to-many
  // link relation attribute (`ReferenceCollectionAttribute`) identifier.
  MeshId attribute = 2;

  // If set to true for a one-to-many link relation (non-versioned) attribute
  // (`ReferenceCollectionAttribute`) this will append `target_object_ids` to
  // already existing ones.
  // If set to false then all currently existing target objects will be
  // replaced by `target_object_ids`.
  //
  // For one-to-one link relation (non-versioned) attribute
  // (`ReferenceAttribute`) this must set to false.
  bool append = 3;

  // If updating a one-to-one link relation (non-versioned) attribute
  // (`ReferenceAttribute`) this must contain zero or one
  // `target_object_ids`. If there is no `target_object_ids` provided then
  // currently existing target object will be removed.
  //
  // If updating a one-to-many link relation (non-versioned) attribute
  // (`ReferenceCollectionAttribute`) this may contain zero, one or more
  // `target_object_ids`s. If there is no `target_object_ids` provided and
  // `append` is set to false then all currently existing target objects will
  // be removed.
  repeated volue.mesh.grpc.type.Guid target_object_ids = 4;
}

message UpdateLinkRelationAttributeResponse {}

// Update request message for versioned one-to-one link relation attribute.
message UpdateVersionedLinkRelationAttributeRequest {
  // ID of the Mesh server's session in which changes should be applied.
  volue.mesh.grpc.type.Guid session_id = 1;

  // All existing versions inside the interval will be deleted.
  // Passing a `null` interval is an error.
  volue.mesh.grpc.type.UtcInterval interval = 2;

  // Versioned one-to-one link relation attribute (`ReferenceSeriesAttribute`)
  // identifier.
  MeshId attribute = 3;

  // `valid_from_time` of all `versions` must be inside the interval.
  repeated LinkRelationVersion versions = 4;
}

message UpdateVersionedLinkRelationAttributeResponse {}

message GetTimeseriesResourceRequest {
  // The server session ID
  volue.mesh.grpc.type.Guid session_id = 1;

  // Time series key of the time series resource to be returned.
  int64 timeseries_resource_key = 2;
}

message UpdateTimeseriesResourceRequest {
  // ID of the Mesh server's session in which changes should be applied.
  volue.mesh.grpc.type.Guid session_id = 1;

  // Time series key of the time series resource to be updated.
  int64 timeseries_resource_key = 2;

  // An array containing field names to be updated.
  // For example to update a time series resource curve type and
  // unit of measurement:
  //   field_mask = ['new_curve_type', 'new_unit_of_measurement']
  //   new_curve_type = CurveType::PIECEWISELINEAR
  //   new_unit_of_measurement = 'new unit'
  google.protobuf.FieldMask field_mask = 3;

  volue.mesh.grpc.type.Curve new_curve_type = 4;
  string new_unit_of_measurement = 5;
}

message UpdateTimeseriesResourceResponse {}

message GetRatingCurveVersionsRequest {
  volue.mesh.grpc.type.Guid session_id = 1;

  // Retrieve all versions that apply in this interval.
  // This may include one version with a `from` before
  // the interval.
  volue.mesh.grpc.type.UtcInterval interval = 2;

  // Don't return `x_range_from` and `x_value_segments`,
  // only `from`s, in the returned `RatingCurveVersion`s.
  bool versions_only = 3;

  // The ID of a rating curve attribute (`RatingCurveAttribute`).
  MeshId attribute = 4;
}

message GetRatingCurveVersionsResponse {
  repeated RatingCurveVersion versions = 1;
}

message UpdateRatingCurveVersionsRequest {
  volue.mesh.grpc.type.Guid session_id = 1;

  // All existing rating curve versions inside the interval will be
  // deleted. Passing a `null` interval is an error.
  volue.mesh.grpc.type.UtcInterval interval = 2;

  // The ID of a rating curve attribute (`RatingCurveAttribute`).
  MeshId attribute = 3;

  // Update rating curve versions for rating curve attribute. The `from` of all
  // versions must be inside the interval. All versions must be sorted by
  // `from`.
  repeated RatingCurveVersion versions = 4;
}

message UpdateRatingCurveVersionsResponse {}

message Timeseries {
  MeshId id = 1;

  // Resolution/spacing for this timeseries.
  volue.mesh.grpc.type.Resolution resolution = 2;

  // Time interval for this timeseries.
  volue.mesh.grpc.type.UtcInterval interval = 3;

  // Data contains an Apache Arrow byte representation of the timeseries points.
  // Stored in the following columns:
  // 0: (uint64) utc_time
  // 1: (uint32) flags
  // 2: (double) value
  bytes data = 4;
}


// Information about physical or virtual time series.
message TimeseriesResource {
  // Unique identifier for physical or virtual time series.
  // Set to 0 if it is a local session time series.
  // This is the only field that could be used for updating 
  // time series attribute with new time series resource.
  int64 timeseries_key = 1;

  // [OUTPUT_ONLY]
  string path = 2;

  // [OUTPUT_ONLY]
  string name = 3;

  // Set to true if it is a local session time series.
  // [OUTPUT_ONLY]
  bool temporary = 4;

  // [OUTPUT_ONLY]
  volue.mesh.grpc.type.Curve curve_type = 5;

  // [OUTPUT_ONLY]
  volue.mesh.grpc.type.Resolution resolution = 6;

  // [OUTPUT_ONLY]
  string unit_of_measurement = 7;

  // [OUTPUT_ONLY]
  string virtual_timeseries_expression = 8;
}

message NumericResults {
    repeated double value = 1;
}

message StringResults {
    repeated string value = 1;
}

// Version information for the Mesh server.
message VersionInfo {
  string version = 1;
  // Friendly name of the Mesh server, e.g.: Volue Mesh Server
  string name = 2;
}

// Every field uniquely identifies a Mesh Object, Attribute or other types.
// For request messages it is enough to provide just one of the fields:
// ID, path or time series key.
// Note: time series key is applicable only for resource time series: physical or virtual.
message MeshId {
  optional volue.mesh.grpc.type.Guid id = 1;
  optional string path = 2;
  optional int64 timeseries_key = 3;
}

// Defines what attributes need to be returned in response message.
message AttributesMasks {
  // Attribute name uniquely identifies attribute within given object.
  // If set then only attributes set in the field mask are read.
  // If any other mask: tag or namespace or `return_no_attributes`
  // flag is also set then an error will be returned.
  // The attribute name provided in the mask must be equal to
  // the actual attribute name in the model.
  // Note: Regular expressions are not supported.
  // See examples below for more details.
  google.protobuf.FieldMask name_mask = 1;

  // Each attribute can have zero, one or more tags.
  // If the tag mask is set then only attributes with
  // at least one tag set in the field mask are read.
  // If multiple tags are provided then all attributes having
  // at least one of them are returned (logical OR).
  // If name mask or `return_no_attributes` flag is also set
  // then an error will be returned.
  // It is allowed to have both: tag mask and namespace mask set.
  // Note: Regular expressions are not supported.
  // See examples below for more details.
  google.protobuf.FieldMask tag_mask = 2;

  // Each attribute can have zero, one or more namespaces.
  // If the namespace mask is set then only attributes with
  // at least one namespace set in the field mask are read.
  // If multiple namespaces are provided in the mask then all
  // attributes having at least one of them are returned (logical OR).
  // Namespace mask does not accept entries with namespaces
  // concatenated with dots '.'. Each namespace mask entry must
  // be a separate namespace.
  // If name mask or `return_no_attributes` flag is also set
  // then an error will be returned.
  // It is allowed to have both: tag mask and namespace mask set.
  // Note: Regular expressions are not supported.
  // See examples below for more details.
  google.protobuf.FieldMask namespace_mask = 3;

  // If set to true then no attributes will be returned.
  // If any mask: name, tag or namespace is also set
  // then an error will be returned.
  // Default value is false (default value for bool in proto3 is false).
  bool return_no_attributes = 4;

  // Multiple attributes may have the same tag or namespace.
  // If both: tag_mask and namespace_masks are provided then only attributes
  // that meet both criteria are returned (intersection/logical AND).
  //
  // Example 1:
  //    Arg:      `name_mask` is set to "Price,Volume,Production"
  //    Response: All attributes with names "Price", "Volume" or "Production"
  //              will be returned.
  //
  // Example 2:
  //    Arg:      `tag_mask` is set to "ProductionAttributes,LocationAttributes"
  //    Response: All attributes with tag name "ProductionAttributes" or
  //              "LocationAttributes" will be returned.
  //    Note:     If attributes A1, A2 have tag "ProductionAttributes" and A3
  //              has "LocationAttributes" then all three attributes
  //              (A1, A2 and A3) will be returned.
  //              Exactly the same rules apply to `namespace_mask`.
  //
  // Example 3:
  //    Arg:      `namespace_mask` is set to "Hydro,Wind".
  //    Response: All attributes with namespace "Hydro" or "Wind" will be returned.
  //    Note:     Suppose there are the following attributes:
  //              - A1 (namespace "EnergySystem.Hydro")
  //              - A2 (namespace "EnergySystem.Wind")
  //              - A3 (namespace "EnergySystem.Carbon")
  //              - A4 (namespace "EnergySystem.Hydro.Small")
  //              - A5 (namespace "Hydro.Normal")
  //              In this case attributes A1, A2, A4 and A5 will be returned.
  //
  // Example 4:
  //    Arg:      `tag_mask` is set to "ProductionAttributes",
  //              `namespace_mask` is set to "Hydro,Wind".
  //    Response: All attributes with tag name "ProductionAttributes" and
  //              namespace "Hydro" or "Wind" will be returned.
  //    Note:     Suppose there are the following attributes:
  //              - A1 (tag "ProductionAttributes", namespace "EnergySystem.Hydro")
  //              - A2 (tag "ProductionAttributes", namespace "EnergySystem.Wind")
  //              - A3 (tag "ProductionAttributes", namespace "EnergySystem.Carbon")
  //              - A4 (tag "LocationAttributes", namespace "EnergySystem.Hydro")
  //              - A5 (tag "LocationAttributes", namespace "EnergySystem.Wind")
  //              In this case attributes A1 and A2 will be returned.
  //
  //  Note: If no masks are provided then all attributes will be returned.
}

message Object {
  volue.mesh.grpc.type.Guid id = 1;
  string path = 2;
  string name = 3;
  string type_name = 4;

  // Relation attribute owning given object, e.g.:
  //   For `SomePowerPlant1` object with path:
  //   - Model/SimpleThermalTestModel/ThermalComponent.ThermalPowerToPlantRef/SomePowerPlant1
  //   Owner will be the `ThermalPowerToPlantRef` attribute.
  MeshId owner_id = 5;
  repeated Attribute attributes = 6;
}

message Attribute {
  // ID of the attribute in the model.
  volue.mesh.grpc.type.Guid id = 1;

  string path = 2;
  string name = 3;
  AttributeDefinition definition = 4;

  // Some attribute types, such as XY-sets, do not include their values in the
  // `Attribute` message. This is because those attributes have potentially
  // large values, and specialized methods exist to handle those values.

  repeated AttributeValue values = 5;

  // For nullable or empty collection types no values will be returned. In such
  // case this `value_type` could be used to check attributes value type.
  AttributeValueType value_type = 6;
  // If the `value_type` is a collection then this flag is set to `True`.
  bool value_type_collection = 7;

  MeshId owner_id = 8;
}

enum AttributeValueType {
  ATTRIBUTE_VALUE_TYPE_UNSPECIFIED = 0;
  ATTRIBUTE_VALUE_TYPE_INT = 1;
  ATTRIBUTE_VALUE_TYPE_DOUBLE = 2;
  ATTRIBUTE_VALUE_TYPE_BOOL = 3;
  ATTRIBUTE_VALUE_TYPE_STRING = 4;
  ATTRIBUTE_VALUE_TYPE_UTC_TIME = 5;
  ATTRIBUTE_VALUE_TYPE_TIMESERIES = 6;
  ATTRIBUTE_VALUE_TYPE_OWNERSHIP_RELATION = 7;
  ATTRIBUTE_VALUE_TYPE_LINK_RELATION = 8;
  ATTRIBUTE_VALUE_TYPE_VERSIONED_LINK_RELATION = 9;
}

message AttributeValue {
  oneof value_oneof {
    int64 int_value = 1;
    double double_value = 2;
    bool boolean_value = 3;
    string string_value = 4;
    google.protobuf.Timestamp utc_time_value = 5;

    TimeseriesAttributeValue timeseries_value = 6;
    OwnershipRelationAttributeValue ownership_relation_value = 7;
    LinkRelationAttributeValue link_relation_value = 8;
    VersionedLinkRelationAttributeValue versioned_link_relation_value = 9;
  }
}

message TimeseriesAttributeValue {
  // Physical or virtual time series from resources if the attribute
  // refers to one.
  // To disconnect time series attribute from already connected time
  // series resource set `new_timeseries_resource_key` to 0 in the
  // `UpdateTimeseriesAttribute` RPC.
  // To update curve type or resolution use `UpdateTimeseriesResource` RPC.
  TimeseriesResource time_series_resource = 1;

  // Expression that is actually used by the time series attribute.
  // It uses local expression if set, otherwise template expression
  // (defined in TimeseriesAttributeDefinition) will be used.
  // When updating expression the new value will always be assigned
  // to local expression.
  // Note: Local expression is set on the object level in the model.
  string expression = 2;

  // Flag indicating expression that is actually used is a local expression.
  // [OUTPUT_ONLY]
  bool is_local_expression = 3;
}

message OwnershipRelationAttributeValue {
  volue.mesh.grpc.type.Guid target_object_id = 1;
}

message LinkRelationAttributeValue {
  volue.mesh.grpc.type.Guid target_object_id = 1;
}

message VersionedLinkRelationAttributeValue {
  repeated LinkRelationVersion versions = 1;
}

message LinkRelationVersion {
  volue.mesh.grpc.type.Guid target_object_id = 1;
  google.protobuf.Timestamp valid_from_time = 2;
}

message AttributeDefinition {
  volue.mesh.grpc.type.Guid id = 1;
  string path = 2;
  string name = 3;

  string description = 4;
  repeated string tags = 5;

  // If an attribute has more than one namespace,
  // they are concatenated with dots '.', e.g.:
  //   namespace1.namespace2
  string name_space = 6;
  string type_name = 7;

  // Specifies minimum and maximum size of a collection of attributes.
  // Minimum and maximum cardinality applies only to a collection of attributes
  // e.g.: collection of double attributes
  // For singular types both minimum and maximum cardinality is set to 1.
  int64 minimum_cardinality = 8;
  int64 maximum_cardinality = 9;

  oneof definition_type_oneof {
    Int64AttributeDefinition int_definition = 10;
    DoubleAttributeDefinition double_definition = 11;
    BooleanAttributeDefinition boolean_definition = 12;
    StringAttributeDefinition string_definition = 13;
    UtcTimeAttributeDefinition utc_time_definition = 14;

    TimeseriesAttributeDefinition timeseries_definition = 15;
    XySetsAttributeDefinition xy_table_definition = 16;
    OwnershipRelationAttributeDefinition ownership_relation_definition = 17;
    // Applicable to all types of link relations.
    LinkRelationAttributeDefinition link_relation_definition = 18;
  }
}

message Int64AttributeDefinition {
  int64 default_value = 1;
  int64 minimum_value = 2;
  int64 maximum_value = 3;
  string unit_of_measurement = 4;
}

message DoubleAttributeDefinition {
  double default_value = 1;
  double minimum_value = 2;
  double maximum_value = 3;
  string unit_of_measurement = 4;
}

message BooleanAttributeDefinition {
  bool default_value = 1;
}

message StringAttributeDefinition {
  string default_value = 1;
}

message UtcTimeAttributeDefinition {
  string default_value = 1;
  string minimum_value = 2;
  string maximum_value = 3;
}

message TimeseriesAttributeDefinition {
  string template_expression = 1;
  string unit_of_measurement = 2;
}

// Describes an axis in a `XySet`.
message XySetAxis {
  string description = 1;
  string unit_of_measurement = 2;
}

message XySetsAttributeDefinition {
  // XYSetAttribute if not versioned. XYZSeriesAttribute if versioned.
  bool versioned = 1;

  XySetAxis x_axis = 2;
  XySetAxis y_axis = 3;

  // Reference values/z values, if applicable.
  optional XySetAxis z_axis = 4;
}

message OwnershipRelationAttributeDefinition {
  string target_object_type_name = 1;
}

message LinkRelationAttributeDefinition {
  string target_object_type_name = 1;
}

enum AttributeView {
  // Not specified, equivalent to BASIC.
  OBJECT_VIEW_UNSPECIFIED = 0;

  // Response will include attribute's ID, name, path and value(s).
  // The default value.
  BASIC = 1;

  // Response will include attribute's ID, name, path, value(s) and
  // complete attribute definition.
  FULL = 2;
}

// An `XyCurve` is a set of (x, y) pairs.
message XyCurve {
  // The reference value of this curve. Also known as the z value.
  double reference_value = 1;

  // Always equal length.
  repeated double x_values = 2;
  repeated double y_values = 3;
}

// An `XySet` is a set of `XyCurve`s indexed by reference values, also known as
// z values.
message XySet {
  // If this `XySet` is a part of a versioned XY set attribute in Mesh
  // `valid_from_time` will contain the start of the active period for
  // this `XySet`. Otherwise `valid_from_time` will be null.
  google.protobuf.Timestamp valid_from_time = 1;

  // A list of `XyCurve`s in this `XySet`. Always sorted by `reference_value`.
  repeated XyCurve xy_curves = 3;
}

// A request for the `XySet`s in an interval, or in the case of `XYSet` attributes
// the single `XySet` owned by that attribute.
message GetXySetsRequest {
  volue.mesh.grpc.type.Guid session_id = 1;

  // For versioned XY sets (`XYZSeriesAttribute`) retrieve all versions that apply
  // in this interval. This may include one version with a `valid_from_time` before
  // the interval.
  //
  // For non-versioned XY set attributes (`XYSetAttribute`) this must be null.
  volue.mesh.grpc.type.UtcInterval interval = 2;

  // Don't return `XyCurve`s, only `valid_from_time`s, in the returned `XySet`s.
  bool versions_only = 3;

  // The ID of a versioned XY set attribute (`XYZSeriesAttribute`) or a non-versioned
  // XY set attribute (`XYSetAttribute`).
  MeshId attribute = 4;
}

message GetXySetsResponse {
  repeated XySet xy_sets = 1;
}

message UpdateXySetsRequest {
  volue.mesh.grpc.type.Guid session_id = 1;

  // For versioned XY sets all existing XY sets inside the interval will be
  // deleted. Passing a `null` interval is an error.
  //
  // For non-versioned XY sets (`XYSetAttribute`) this must be null.
  volue.mesh.grpc.type.UtcInterval interval = 2;

  // The ID of a versioned XY set attribute (`XYZSeriesAttribute`) or a non-versioned
  // XY set attribute (`XYSetAttribute`).
  MeshId attribute = 3;

  // If updating a versioned XY set attribute (`XYZSeriesAttribute`) the `XySet`s
  // in `xy_sets` will be inserted in the XY set series. The `valid_from_time` of all
  // XY sets must be inside the interval.
  //
  // If updating a non-versioned XY set attribute (`XYSetAttribute`) this must contain
  // zero or one `XySet`.
  repeated XySet xy_sets = 4;
}

message UpdateXySetsResponse {}

message RatingCurveSegment {
  double x_range_until = 1;
  double factor_a = 2;
  double factor_b = 3;
  double factor_c = 4;
}

message RatingCurveVersion {
  google.protobuf.Timestamp from = 1;
  double x_range_from = 2;
  repeated RatingCurveSegment x_value_segments = 3;
}

enum LogLevel {
  TRACE = 0;
  DEBUG = 1;
  INFO = 2;
  WARN = 3;
  ERR = 4;
  OFF = 5;
}

message UpdateLogLevelRequest {
  LogLevel new_log_level = 1;
}

message UpdateLogLevelResponse {}

message GetLogLevelResponse {
  // log level retrieved from Mesh
  LogLevel log_level = 1;
}

message AttributePair {

    // A time series attribute name.
    string source_attribute_name = 1;

    // The target can either be a direct name or a search/navigation spec.
    oneof target_attribute {
        // Use name when the target attribute is found by internal lookup on target object.
        string target_attribute_name = 2;

        // Use search when the target attribute is found by general search from target object.
        // To accept a search based mapping, the result of the search must be 1 time series attribute.

        // The attribute search expression may contain a macro named $ObjName to make search more specific.
        // The value of the macro is associated with the source object name.
        // By using this macro it is possible to reach out to target series in a more generic way.
        // Example: ../../*[.Type=Asset&&.Name=$ObjName&&...Name=C3].Ts1
        // When at a source object having a name CA1, the search string will be expanded to ../../*[.Type=Asset&&.Name=CA1&&...Name=C3].Ts1
        // Because the structure of the source and target hierarchy normally is the same, this will narrow the search.
        string target_attribute_search = 3;
    }
}
// Mapping details
message TypeAttributeMapping {

    // The Mesh object type name.
    // When specified, only time series that match this filter will be considered for copy.
    string object_type_name = 1;

    // Mapping between time series source attribute name and target name.
    // Target name may be a search expression.
    repeated AttributePair attribute_mapping = 2;
}

message CopyTimeseriesBetweenObjectsRequest {
  volue.mesh.grpc.type.Guid session_id = 1;

  // If interval is not supplied, the request will do a tentative operation
  // which logs what time series will be copied if a valid interval is given.
  volue.mesh.grpc.type.UtcInterval interval = 2;
  
  // Identify the root object of the Source hierarchy (path or guid)
  MeshId source = 3;
  // Identify the root object of the Target hierarchy (path or guid)
  // In case attribute mapping is enabled the source and target may refer to same object
  MeshId target = 4;

  // Optional: Defines which part of source hierarchy to copy and potentially also where to copy.
  // In case this mapping is not specified the operation copies everything that matches general criteria.
  // General criteria: source series can provide values (ts binding or expression) and target series can be persisted.
  repeated TypeAttributeMapping mapping = 5;
}

message CopyTimeseriesBetweenObjectsResponse {

    // Number of source series considered.
    int64 source_series_count = 1;

    // Number of target series considered.
    int64 target_series_count = 2;

    // The number of series that will be copied if input interval is defined.
    // When this value is > 0 the operations were successful.
    int64 match_series_count = 3;
}

// A text resource in Mesh can be compared with a text file located at a given catalog.
// The API supports reading, writing and browsing such Mesh resource objects.

message ListTextResourcesRequest {
    volue.mesh.grpc.type.Guid session_id = 1;

    // The catalog in which we are looking for Text resources (files).
    // In case the option `include_subcatalogs` is true, this catalog is treated as the root 
    // of a hierarchical search.
    MeshId catalog = 2;
    
    // Empty, simple "contains" pattern or a regular expression.
    // In case it is empty, all Text resources are added to reply list.
    // Else, the system will try to look for a Text resource which contains the `name_mask` value.
    // For instance ".json" will match "AB.json", "A.jsonB" etc  (contains somewhere in the name gives match).
    // If contain operation fails, the system tries to match the name of the Text resource with the `name_mask` value as a regular expression.
    string name_mask = 3;
    
    // Include search for matches in subcatalogs
    bool include_subcatalogs = 4;
}

message ListTextResourcesResponse {
    // Resources that match request
    repeated MeshId resources = 1;
}

message GetTextResourceRequest {
    volue.mesh.grpc.type.Guid session_id = 1;

    // The path must lead to an existing Text Resource
    // If MeshId contains a GUID, the system will resolve that GUID and do not try the MeshId path definition.
    // A text path has the following format:
    // Resource/Catalog1/CatalogX/SomeTextResourceName
    MeshId resource = 2;
}

message GetTextResourceResponse {
    volue.mesh.grpc.type.Guid id = 1;
    string path = 2;
    // The contents of the Text resource 
    string text = 3;
}

message WriteTextResourceRequest {
    volue.mesh.grpc.type.Guid session_id = 1;

    // The path may lead to an existing Text Resource
    // Or, in case allow_create is true, the resource will be created
    // This may create new catalogs, all or from a certain level
    // The first part must be Resource, the last part is taken to be the Text resource name
    // Resource/SomeTextResourceName is not accepted
    MeshId resource = 2;
    
    // If set to false the target must be an existing text resource
    bool allow_create = 3;

    // The contents
    string text = 4;
}

message WriteTextResourceResponse {}
