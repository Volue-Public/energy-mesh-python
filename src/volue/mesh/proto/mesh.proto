syntax = "proto3";

import "google/protobuf/empty.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";

package volue.mesh.v1alpha;


// Authentication
//
// When Mesh is configured to require authentication an access token is
// necessary for most calls. You can acquire an access token through Kerberos
// authentication as described above the `AuthenticateKerberos` method. Access
// tokens are passed in the `Authorization` metadata field of each RPC with the
// format `Bearer <access token>`.
//
// Many gRPC libraries provide call credential types that correctly pass the
// access token to the server, for example `grpc::AccessTokenCredentials` in C++.
// These mechanisms will generally take the bare access token (without `Bearer`),
// and create the `Bearer <access token>` string internally.
//
// Access tokens expire after an hour and should be refreshed before then.
// Getting a new token early, for example after half the expiration time, is
// recommended.


service MeshService {
  rpc GetVersion(google.protobuf.Empty) returns (VersionInfo) {}

  // Authenticate using Kerberos
  //
  // Perform a potentially multi-leg Kerberos authentication where the client
  // and the server sends Kerberos tickets back and forth until a complete
  // security context is established or an error occurs.
  //
  // On success the final response from the server will contain a bearer token
  // that should be used as a token in calls that require authorization, as
  // well as the expiration time for that token.
  rpc AuthenticateKerberos(stream google.protobuf.BytesValue) returns (stream AuthenticateKerberosResponse) {}

  // Revoke an access token received from `AuthenticateKerberos`, causing
  // it to become immediately unusable. If the RPC returns without error
  // the operation succeeded *or* the token does not exist.
  rpc RevokeAccessToken(google.protobuf.StringValue) returns (google.protobuf.Empty) {}

  // Returns the identity that was used to create the access token authorizing
  // this call.
  rpc GetUserIdentity(google.protobuf.Empty) returns (UserIdentity) {}

  rpc ReadTimeseries(ReadTimeseriesRequest) returns (ReadTimeseriesResponse) {}
  rpc WriteTimeseries(WriteTimeseriesRequest) returns (google.protobuf.Empty) {}

  // Start a Mesh session, return the id of the session
  rpc StartSession(google.protobuf.Empty) returns (Guid) {}

  rpc EndSession(Guid) returns (google.protobuf.Empty) {}
  rpc Commit(Guid) returns (google.protobuf.Empty) {}
  rpc Rollback(Guid) returns (google.protobuf.Empty) {}
}


message AuthenticateKerberosResponse {
  // The Kerberos ticket returned by the server's AcceptSecurityContext call.
  bytes kerberos_token = 1;

  // A base64 encoded access token.
  string bearer_token = 2;

  // The access token will become invalid at this time.
  google.protobuf.Duration token_duration = 3;
}

message UserIdentity {
  // A human readable name identifying this user. This name should not be
  // used as an unique identifier for the user as it may be identical
  // between users and change over time.
  string display_name = 1;

  // Where the user identity came from. Can be used together with the identifier
  // as a unique key.
  string source = 2;

  // An identifier that uniquely identifies the user within `source`, but
  // not necessarily globally. Combining `source` and `identifier` should
  // result in a globally unique identifier for the user.
  string identifier = 3;
}

message Guid {
  // Bytes in LITTLE ENDIAN format
  bytes bytes_le = 1;
}

message UtcInterval {
  google.protobuf.Timestamp start_time = 1;
  google.protobuf.Timestamp end_time = 2;
}

// Contains one or more ways to uniquely identify an object
message ObjectId {
  optional int64 timskey = 1;
  optional Guid guid = 2;
  optional string full_name = 3; // Not implemented yet
}

message VersionInfo {
  string version = 1;
  string name = 2;
  string build_date = 3;
  string commit = 4;
  string full_version = 5;
}

message Resolution {
  enum ResolutionType {
    BREAKPOINT = 0;
    MIN15 = 1;
    HOUR = 2;
    DAY = 3;
    WEEK = 4;
    MONTH = 5;
    YEAR = 6;
  }
  ResolutionType type = 1;
}

message Timeseries {
  ObjectId object_id = 1;

  Resolution resolution = 2;

  // source_delta_t denotes which resolution this
  // timeseries has in storage. If delta_t and source_delta_t
  // doesn't match, then you are not allowed to write.
  // optional uint64 source_resolution = 2;

  // TODO:
  // optional curve_type <- Relevant when visualizing data
  // optional unit_of_measurement <- Relevant
  // optional version

  UtcInterval interval = 3;

  // data contains an apache arrow byte representation of the timeseries points.
  // Stored in the following columns:
  // 0: (uint64) ticks
  // 1: (uint32) flags
  // 2: (double) value
  bytes data = 4;
}

// Not implemented server-side yet {
message Transformation {
  Resolution resolution = 1;
  enum TransformationType {
    SUM = 0;
    SUMI = 1;
    AVG = 2;
    AVGI = 3;
    FIRST = 4;
    LAST = 5;
    MIN = 6;
    MAX = 7;
  }
  TransformationType type = 2;

  // timezone is relevant when transforming to Day/Week/Month, 
  // to know when exactly the local day begins. Thus we need
  // to include some time zone info, to be able to do the transform:
  // TODO: optional string timezone = 3;
}
// }

message ReadTimeseriesRequest {
  Guid session_id = 1;

  // The search can return more than one valid object.
  // In that case, the timeseries will be read for all
  // valid objects, for the requested interval. 
  ObjectId object_id = 2;
  UtcInterval interval = 3;

  // if we request points from a breakpoint series, the actual points
  // describing our interval, might be long before the actual interval.
  // Should we then return the actual point (outside our interval),
  // or a "fake"/virtual point inside our interval?
  // TODO: bool allow_virtual_points?

  // TODO: optional Transformation transformation = 4;
}

message ReadTimeseriesResponse {
  // A search expression may return several timeseries.
  repeated Timeseries timeseries = 1;
}

message WriteTimeseriesRequest {
  Guid session_id = 1;  
  
  // Must point to exactly one Timeseries
  // (entry, attribute or value)
  ObjectId object_id = 2;

  // The resolution of the points has to fit the stored timeseries. 
  // Otherwise it will be rejected.
  Timeseries timeseries = 3;
}
