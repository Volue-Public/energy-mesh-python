

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Examples &mdash; volue.mesh 1.14.0-dev documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/copybutton.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="_static/clipboard.min.js"></script>
        <script src="_static/copybutton.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Client authentication" href="authentication.html" />
    <link rel="prev" title="HydSim" href="hydsim.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> volue.mesh
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Welcome</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quickstart guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction_to_mesh.html">An introduction to Mesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="hydsim.html">HydSim</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#best-practices">Best practices</a></li>
<li class="toctree-l2"><a class="reference internal" href="#quickstart">Quickstart</a></li>
<li class="toctree-l2"><a class="reference internal" href="#authorization">Authorization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#connect">Connect</a></li>
<li class="toctree-l2"><a class="reference internal" href="#connect-asynchronously">Connect, asynchronously</a></li>
<li class="toctree-l2"><a class="reference internal" href="#connect-using-external-access-token">Connect using external access token</a></li>
<li class="toctree-l2"><a class="reference internal" href="#get-version">Get version</a></li>
<li class="toctree-l2"><a class="reference internal" href="#read-time-series">Read time series</a></li>
<li class="toctree-l2"><a class="reference internal" href="#read-time-series-asynchronously">Read time series, asynchronously</a></li>
<li class="toctree-l2"><a class="reference internal" href="#read-and-process-time-series-asynchronously">Read and process time series, asynchronously</a></li>
<li class="toctree-l2"><a class="reference internal" href="#search-for-time-series-attributes">Search for time series attributes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#traverse-model">Traverse model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-time-series-with-pandas">Using time series with pandas</a></li>
<li class="toctree-l2"><a class="reference internal" href="#working-with-link-relations">Working with link relations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#working-with-model-objects-and-attributes">Working with model (objects and attributes)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#working-with-rating-curves">Working with rating curves</a></li>
<li class="toctree-l2"><a class="reference internal" href="#working-with-sessions">Working with sessions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#working-with-xy-sets">Working with XY sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="#write-time-series">Write time series</a></li>
<li class="toctree-l2"><a class="reference internal" href="#run-simulations">Run simulations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#run-inflow-calculations">Run inflow calculations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="authentication.html">Client authentication</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Versions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="versions.html">Versions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">SDK Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api.html">API documentation</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">volue.mesh</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Examples</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/examples.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Permalink to this heading">¶</a></h1>
<p>This section contains code examples. Most of them require specific Mesh model on the server side.
Best practice is to copy the examples scripts that are of interest for you together with helpers.py</p>
<div class="section" id="best-practices">
<h2>Best practices<a class="headerlink" href="#best-practices" title="Permalink to this heading">¶</a></h2>
<ol class="arabic">
<li><p>Checkout or open in GitHub git tag corresponding to the Mesh Python SDK
version you are using. E.g. for Mesh Python SDK v1.7 it is:
<a class="reference external" href="https://github.com/Volue-Public/energy-mesh-python/tree/v1.7.0">https://github.com/Volue-Public/energy-mesh-python/tree/v1.7.0</a></p></li>
<li><p>Copy either the whole <cite>examples</cite> directory or specific examples script(s)
together with helpers.py and paste it to your own workspace.</p></li>
<li><p>Run example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">.</span>\<span class="n">examples</span>\<span class="n">get_version</span><span class="o">.</span><span class="n">py</span> <span class="n">localhost</span><span class="p">:</span><span class="mi">50051</span> <span class="n">c</span><span class="p">:</span>\<span class="n">certificate</span><span class="o">.</span><span class="n">pem</span>
</pre></div>
</div>
<p>First argument - Mesh server address with port. Default value is
localhost:50051.</p>
<p>Second argument - path to PEM-encoded TLS certificate used by Mesh server.
Skip it if the Mesh server is configured to accept insecure gRPC connections.
If provided, then make sure that instead of <code class="xref py py-meth docutils literal notranslate"><span class="pre">volue.mesh.Connection.Session.insecure()</span></code>,
the <code class="xref py py-meth docutils literal notranslate"><span class="pre">volue.mesh.Connection.Session.with_tls()</span></code> is used to establish
connection to Mesh.</p>
</li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Starting from Mesh Python SDK 1.9, in all examples the connection to Mesh
server is established using <code class="xref py py-meth docutils literal notranslate"><span class="pre">volue.mesh.Connection.Session.insecure()</span></code>.
To use a different connection type, e.g.: with TLS, the user has to change
the example script. The PEM-encoded TLS certificate passed as a second
argument will be discarded if an insecure connection is used.</p>
</div>
</div>
<div class="section" id="quickstart">
<h2>Quickstart<a class="headerlink" href="#quickstart" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">helpers</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">volue.mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">Connection</span>


<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Showing the quickest way to get started.&quot;&quot;&quot;</span>

    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = Connection.with_tls(address, tls_root_pem_cert)</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

    <span class="c1"># Which version is the server running</span>
    <span class="n">version_info</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">get_version</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Connected to </span><span class="si">{</span><span class="n">version_info</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">version_info</span><span class="o">.</span><span class="n">version</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Create a remote session on the Volue Mesh server</span>
    <span class="n">session</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">()</span>
    <span class="n">session</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You have now an open session and can request time series&quot;</span><span class="p">)</span>

    <span class="c1"># Close the remote session</span>
    <span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">get_connection_info</span><span class="p">()</span>
    <span class="n">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="authorization">
<h2>Authorization<a class="headerlink" href="#authorization" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">helpers</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">volue.mesh.aio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">volue</span><span class="w"> </span><span class="kn">import</span> <span class="n">mesh</span>


<span class="k">def</span><span class="w"> </span><span class="nf">sync_auth</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">,</span> <span class="n">service_principal</span><span class="p">,</span> <span class="n">user_principal</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Synchronous authentication example: &quot;</span><span class="p">)</span>

    <span class="n">connection</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">Connection</span><span class="o">.</span><span class="n">with_kerberos</span><span class="p">(</span>
        <span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">,</span> <span class="n">service_principal</span><span class="p">,</span> <span class="n">user_principal</span>
    <span class="p">)</span>

    <span class="n">user_identity</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">get_user_identity</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">user_identity</span><span class="p">)</span>

    <span class="c1"># revoke no longer used token</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">revoke_access_token</span><span class="p">()</span>


<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">async_auth</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">,</span> <span class="n">service_principal</span><span class="p">,</span> <span class="n">user_principal</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Asynchronous authentication example:&quot;</span><span class="p">)</span>

    <span class="n">connection</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">aio</span><span class="o">.</span><span class="n">Connection</span><span class="o">.</span><span class="n">with_kerberos</span><span class="p">(</span>
        <span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">,</span> <span class="n">service_principal</span><span class="p">,</span> <span class="n">user_principal</span>
    <span class="p">)</span>

    <span class="n">user_identity</span> <span class="o">=</span> <span class="k">await</span> <span class="n">connection</span><span class="o">.</span><span class="n">get_user_identity</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">user_identity</span><span class="p">)</span>

    <span class="c1"># revoke no longer used token</span>
    <span class="k">await</span> <span class="n">connection</span><span class="o">.</span><span class="n">revoke_access_token</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Showing how to authorize to gRPC Mesh server.&quot;&quot;&quot;</span>

    <span class="c1"># If Mesh gRPC server is running as a service user,</span>
    <span class="c1"># for example LocalSystem, NetworkService or a user account</span>
    <span class="c1"># with a registered service principal name then it is enough</span>
    <span class="c1"># to provide hostname as service principal, e.g.:</span>
    <span class="c1">#   &#39;HOST/hostname.companyad.company.com&#39;</span>
    <span class="c1"># If Mesh gRPC server is running as a user account without</span>
    <span class="c1"># registered service principal name then it is enough to provide</span>
    <span class="c1"># user account name running Mesh server as service principal, e.g.:</span>
    <span class="c1">#   &#39;ad\\user.name&#39; or r&#39;ad\user.name&#39;</span>
    <span class="c1"># Note: winkerberos converts service principal name if provided in</span>
    <span class="c1">#       RFC-2078 format. &#39;@&#39; is converted to &#39;/&#39; if there is no &#39;/&#39;</span>
    <span class="c1">#       character in the service principal name. E.g.:</span>
    <span class="c1">#           service@hostname</span>
    <span class="c1">#       Would be converted to:</span>
    <span class="c1">#           service/hostname</span>
    <span class="n">service_principal</span> <span class="o">=</span> <span class="s2">&quot;HOST/hostname.companyad.company.com&quot;</span>
    <span class="n">user_principal</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">sync_auth</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">,</span> <span class="n">service_principal</span><span class="p">,</span> <span class="n">user_principal</span><span class="p">)</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span>
        <span class="n">async_auth</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">,</span> <span class="n">service_principal</span><span class="p">,</span> <span class="n">user_principal</span><span class="p">)</span>
    <span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># This will authenticate Python client (receive authorization token from Mesh),</span>
    <span class="c1"># then send gRPC request that requires authorization (e.g.: GetUserIdentity)</span>
    <span class="c1"># and print the result. If your user name info is printed, you have successfully</span>
    <span class="c1"># communicated with the server.</span>
    <span class="c1">#</span>
    <span class="c1"># This requires Mesh server to be running with enabled TLS and Kerberos options.</span>

    <span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">get_connection_info</span><span class="p">()</span>
<span class="c1">#    main(address, tls_root_pem_cert)</span>
</pre></div>
</div>
</div>
<div class="section" id="connect">
<h2>Connect<a class="headerlink" href="#connect" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">helpers</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">volue.mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">Connection</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_version</span><span class="p">(</span><span class="n">connection</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Showing how to send get the server version.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;1. Requesting server version&quot;</span><span class="p">)</span>
    <span class="n">version</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">get_version</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;2. Server version is </span><span class="si">{</span><span class="n">version</span><span class="o">.</span><span class="n">version</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">start_and_end_session</span><span class="p">(</span><span class="n">session</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Showing how to start and end a session.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A. Starting session&quot;</span><span class="p">)</span>
    <span class="n">session</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;B. Ending session&quot;</span><span class="p">)</span>
    <span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Showing how to connect to a server and run two tasks sequentially.&quot;&quot;&quot;</span>

    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = Connection.with_tls(address, tls_root_pem_cert)</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

    <span class="n">get_version</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>
    <span class="n">start_and_end_session</span><span class="p">(</span><span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">())</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">get_connection_info</span><span class="p">()</span>
    <span class="n">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done&quot;</span><span class="p">)</span>

<span class="c1"># Outputs:</span>
<span class="c1"># 1. Requesting server version</span>
<span class="c1"># 2. Server version is 1.12.5.0-dev</span>
<span class="c1"># A. Starting session</span>
<span class="c1"># B. Ending session</span>
<span class="c1"># Done</span>
</pre></div>
</div>
</div>
<div class="section" id="connect-asynchronously">
<h2>Connect, asynchronously<a class="headerlink" href="#connect-asynchronously" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">helpers</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">volue.mesh.aio</span><span class="w"> </span><span class="kn">import</span> <span class="n">Connection</span>


<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">get_version</span><span class="p">(</span><span class="n">connection</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Showing how to get the server version.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;1. Requesting server version&quot;</span><span class="p">)</span>
    <span class="n">version</span> <span class="o">=</span> <span class="k">await</span> <span class="n">connection</span><span class="o">.</span><span class="n">get_version</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;2. Server version is </span><span class="si">{</span><span class="n">version</span><span class="o">.</span><span class="n">version</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">start_and_end_session</span><span class="p">(</span><span class="n">session</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Showing how to start and end a session.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A. Starting session&quot;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">session</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;B. Ending session&quot;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Showing how to connect to a server and run two tasks concurrently.&quot;&quot;&quot;</span>
    <span class="c1"># Creating a connection, but not sending any requests yet.</span>

    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = Connection.with_tls(address, tls_root_pem_cert)</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

    <span class="c1"># Indicate that these two functions can be run concurrently.</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
        <span class="n">get_version</span><span class="p">(</span><span class="n">connection</span><span class="p">),</span> <span class="n">start_and_end_session</span><span class="p">(</span><span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">())</span>
    <span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">get_connection_info</span><span class="p">()</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done&quot;</span><span class="p">)</span>

<span class="c1"># Outputs:</span>
<span class="c1"># 1. Requesting server version</span>
<span class="c1"># A. Starting session</span>
<span class="c1"># 2. Server version is 1.12.5.0-dev</span>
<span class="c1"># B. Ending session</span>
<span class="c1"># Done</span>
</pre></div>
</div>
</div>
<div class="section" id="connect-using-external-access-token">
<h2>Connect using external access token<a class="headerlink" href="#connect-using-external-access-token" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">helpers</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">volue.mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">Connection</span>


<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Showing how to authorize to gRPC Mesh server using externally obtained</span>
<span class="sd">    access token, e.g: a OAuth JWT. Obtaining the access token is out of scope</span>
<span class="sd">    for this example.</span>

<span class="sd">    Depending on your environment, e.g.: Azure AD, using libraries like</span>
<span class="sd">    Microsoft Authentication Library (MSAL) for getting the tokens is</span>
<span class="sd">    suggested.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">token</span> <span class="o">=</span> <span class="s2">&quot;my_token&quot;</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">Connection</span><span class="o">.</span><span class="n">with_external_access_token</span><span class="p">(</span>
        <span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">,</span> <span class="n">access_token</span><span class="o">=</span><span class="n">token</span>
    <span class="p">)</span>

    <span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="c1"># Print user information contained in the access token.</span>
        <span class="n">user_identity</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">get_user_identity</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">user_identity</span><span class="p">)</span>

        <span class="c1"># Read some time series data.</span>
        <span class="c1"># This requires the user has time series read permissions.</span>
        <span class="n">timeseries_key</span> <span class="o">=</span> <span class="mi">1388</span>
        <span class="n">timeseries</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">read_timeseries_points</span><span class="p">(</span>
            <span class="n">timeseries_key</span><span class="p">,</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2014</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2015</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">timeseries</span><span class="o">.</span><span class="n">arrow_table</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">())</span>

        <span class="c1"># For long running sessions it may be necessary to refresh the access</span>
        <span class="c1"># token.</span>
        <span class="c1"># Other possibility would be to catch grpc.RpcError with status code</span>
        <span class="c1"># UNAUTHENTICATED and then get new access token and update it in the</span>
        <span class="c1"># Mesh connection using `update_external_access_token`.</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">update_external_access_token</span><span class="p">(</span><span class="s2">&quot;my_new_access_token&quot;</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># This requires Mesh server to be running with enabled TLS and OAuth options.</span>
    <span class="c1"># Obtaining access token is out of the scope for this example.</span>

    <span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">get_connection_info</span><span class="p">()</span>
    <span class="c1"># main(address, tls_root_pem_cert)</span>
</pre></div>
</div>
</div>
<div class="section" id="get-version">
<h2>Get version<a class="headerlink" href="#get-version" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">helpers</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">volue.mesh.aio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">volue</span><span class="w"> </span><span class="kn">import</span> <span class="n">mesh</span>


<span class="k">def</span><span class="w"> </span><span class="nf">sync_get_version</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Synchronous get version:&quot;</span><span class="p">)</span>

    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = mesh.Connection.with_tls(address, tls_root_pem_cert)</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

    <span class="n">version_info</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">get_version</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">version_info</span><span class="o">.</span><span class="n">version</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">async_get_version</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Asynchronous get version:&quot;</span><span class="p">)</span>

    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = mesh.aio.Connection.with_tls(address, tls_root_pem_cert)</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">aio</span><span class="o">.</span><span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

    <span class="n">version_info</span> <span class="o">=</span> <span class="k">await</span> <span class="n">connection</span><span class="o">.</span><span class="n">get_version</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">version_info</span><span class="o">.</span><span class="n">version</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># This will request and print version info from the mesh server.</span>
    <span class="c1"># If some sensible version info is printed, you have successfully</span>
    <span class="c1"># communicated with the server.</span>
    <span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">get_connection_info</span><span class="p">()</span>
    <span class="n">sync_get_version</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">)</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">async_get_version</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="read-time-series">
<h2>Read time series<a class="headerlink" href="#read-time-series" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">uuid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">helpers</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">volue.mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">Connection</span>


<span class="k">def</span><span class="w"> </span><span class="nf">read_timeseries_points</span><span class="p">(</span><span class="n">session</span><span class="p">:</span> <span class="n">Connection</span><span class="o">.</span><span class="n">Session</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Showing how to read time series points.&quot;&quot;&quot;</span>

    <span class="c1"># Define the time series identifier, it can be:</span>
    <span class="c1"># - time series key of a physical time series</span>
    <span class="c1"># - path of a time series attribute that is connected to a physical time series</span>
    <span class="c1"># - ID of a time series attribute that is connected to a physical time series</span>
    <span class="n">timeseries_key</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">timeseries_attribute_path</span> <span class="o">=</span> <span class="s2">&quot;Model/SimpleThermalTestModel/ThermalComponent/SomePowerPlant1/SomePowerPlantChimney2.TsRawAtt&quot;</span>
    <span class="n">timeseries_attribute_id</span> <span class="o">=</span> <span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span><span class="p">(</span><span class="s2">&quot;e5df77a9-8b60-4b0a-aa1b-3c3957c538a0&quot;</span><span class="p">)</span>

    <span class="c1"># Defining a time interval to read time series from.</span>
    <span class="c1"># If no time zone is provided then it will be treated as UTC.</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Each time series point occupies 20 bytes. By default gRPC has a limitation of 4MB inbound message size.</span>
    <span class="c1"># In case of larger data volumes please send request data in chunks.</span>
    <span class="c1"># E.g.: call multiple times `read_timeseries_points` with shorter interval.</span>

    <span class="c1"># Send request to read time series based on time series key.</span>
    <span class="n">timeseries</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">read_timeseries_points</span><span class="p">(</span>
        <span class="n">target</span><span class="o">=</span><span class="n">timeseries_key</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="n">end</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Read </span><span class="si">{</span><span class="n">timeseries</span><span class="o">.</span><span class="n">number_of_points</span><span class="si">}</span><span class="s2"> points using time series key.&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">timeseries</span><span class="o">.</span><span class="n">arrow_table</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">())</span>

    <span class="c1"># Send requests to read time series based on time series attribute path.</span>
    <span class="n">timeseries</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">read_timeseries_points</span><span class="p">(</span>
        <span class="n">target</span><span class="o">=</span><span class="n">timeseries_attribute_path</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="n">end</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Read </span><span class="si">{</span><span class="n">timeseries</span><span class="o">.</span><span class="n">number_of_points</span><span class="si">}</span><span class="s2"> points using time series attribute path.&quot;</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">timeseries</span><span class="o">.</span><span class="n">arrow_table</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">())</span>

    <span class="c1"># Send requests to read time series based on time series attribute ID.</span>
    <span class="c1"># Attribute IDs are auto-generated when an object is created.</span>
    <span class="c1"># That is why we can&#39;t use any fixed ID in this example and the code is commented out.</span>
    <span class="c1"># timeseries = session.read_timeseries_points(</span>
    <span class="c1">#     target=timeseries_attribute_id, start_time=start, end_time=end</span>
    <span class="c1"># )</span>
    <span class="c1"># print(f&quot;Read {timeseries.number_of_points} points using time series attribute ID.&quot;)</span>
    <span class="c1"># print(timeseries.arrow_table.to_pandas())</span>


<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Showing how to get time series points.&quot;&quot;&quot;</span>

    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = Connection.with_tls(address, tls_root_pem_cert)</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="n">read_timeseries_points</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">get_connection_info</span><span class="p">()</span>
    <span class="n">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="read-time-series-asynchronously">
<h2>Read time series, asynchronously<a class="headerlink" href="#read-time-series-asynchronously" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uuid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">helpers</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">volue.mesh.aio</span><span class="w"> </span><span class="kn">import</span> <span class="n">Connection</span>


<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">read_timeseries_points_async</span><span class="p">(</span><span class="n">session</span><span class="p">:</span> <span class="n">Connection</span><span class="o">.</span><span class="n">Session</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Showing how to read time series points.&quot;&quot;&quot;</span>

    <span class="c1"># Define the time series identifier, it can be:</span>
    <span class="c1"># - time series key of a physical time series</span>
    <span class="c1"># - path of a time series attribute that is connected to a physical time series</span>
    <span class="c1"># - ID of a time series attribute that is connected to a physical time series</span>
    <span class="n">timeseries_key</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">timeseries_attribute_path</span> <span class="o">=</span> <span class="s2">&quot;Model/SimpleThermalTestModel/ThermalComponent/SomePowerPlant1/SomePowerPlantChimney2.TsRawAtt&quot;</span>
    <span class="n">timeseries_attribute_id</span> <span class="o">=</span> <span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span><span class="p">(</span><span class="s2">&quot;e5df77a9-8b60-4b0a-aa1b-3c3957c538a0&quot;</span><span class="p">)</span>

    <span class="c1"># Defining a time interval to read time series from.</span>
    <span class="c1"># If no time zone is provided then it will be treated as UTC.</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Each time series point occupies 20 bytes. By default gRPC has a limitation of 4MB inbound message size.</span>
    <span class="c1"># In case of larger data volumes please send request data in chunks.</span>
    <span class="c1"># E.g.: call multiple times `read_timeseries_points` with shorter interval.</span>

    <span class="c1"># Send request to read time series based on time series key.</span>
    <span class="n">timeseries</span> <span class="o">=</span> <span class="k">await</span> <span class="n">session</span><span class="o">.</span><span class="n">read_timeseries_points</span><span class="p">(</span>
        <span class="n">target</span><span class="o">=</span><span class="n">timeseries_key</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="n">end</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Read </span><span class="si">{</span><span class="n">timeseries</span><span class="o">.</span><span class="n">number_of_points</span><span class="si">}</span><span class="s2"> points using time series key.&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">timeseries</span><span class="o">.</span><span class="n">arrow_table</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">())</span>

    <span class="c1"># Send requests to read time series based on time series attribute path.</span>
    <span class="n">timeseries</span> <span class="o">=</span> <span class="k">await</span> <span class="n">session</span><span class="o">.</span><span class="n">read_timeseries_points</span><span class="p">(</span>
        <span class="n">target</span><span class="o">=</span><span class="n">timeseries_attribute_path</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="n">end</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Read </span><span class="si">{</span><span class="n">timeseries</span><span class="o">.</span><span class="n">number_of_points</span><span class="si">}</span><span class="s2"> points using time series attribute path.&quot;</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">timeseries</span><span class="o">.</span><span class="n">arrow_table</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">())</span>

    <span class="c1"># Send requests to read time series based on time series attribute ID.</span>
    <span class="c1"># Attribute IDs are auto-generated when an object is created.</span>
    <span class="c1"># That is why we can&#39;t use any fixed ID in this example and the code is commented out.</span>
    <span class="c1"># timeseries = await session.read_timeseries_points(</span>
    <span class="c1">#     target=timeseries_attribute_id, start_time=start, end_time=end</span>
    <span class="c1"># )</span>
    <span class="c1"># print(f&quot;Read {timeseries.number_of_points} points using time series attribute ID.&quot;)</span>
    <span class="c1"># print(timeseries.arrow_table.to_pandas())</span>


<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Showing how to get time series points asynchronously.&quot;&quot;&quot;</span>

    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = Connection.with_tls(address, tls_root_pem_cert)</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">read_timeseries_points_async</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">get_connection_info</span><span class="p">()</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="read-and-process-time-series-asynchronously">
<h2>Read and process time series, asynchronously<a class="headerlink" href="#read-and-process-time-series-asynchronously" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">grpc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">helpers</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">volue.mesh.aio</span><span class="w"> </span><span class="kn">import</span> <span class="n">Connection</span>


<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">process_timeseries_values</span><span class="p">(</span><span class="n">arrow_table</span><span class="p">):</span>
    <span class="c1"># the processing can also be an async IO call</span>
    <span class="c1"># to e.g. separate service</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing completed - </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">arrow_table</span><span class="p">)</span><span class="si">}</span><span class="s2"> points were processed&quot;</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">read_timeseries_points</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

    <span class="c1"># read operation can be a long running operation</span>
    <span class="c1"># with asyncio API we can switch to do something else</span>
    <span class="c1"># while waiting for the read operation to complete</span>
    <span class="c1"># (e.g. doing processing for already returned time series)</span>
    <span class="n">timeseries_read</span> <span class="o">=</span> <span class="k">await</span> <span class="n">session</span><span class="o">.</span><span class="n">read_timeseries_points</span><span class="p">(</span>
        <span class="n">target</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="n">end_time</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">timeseries_read</span><span class="o">.</span><span class="n">arrow_table</span>


<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">handle_timeseries</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
    <span class="n">arrow_table</span> <span class="o">=</span> <span class="k">await</span> <span class="n">read_timeseries_points</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">process_timeseries_values</span><span class="p">(</span><span class="n">arrow_table</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Showing how to use asynchronous connection in a real-world scenario.</span>
<span class="sd">    First multiple time series are returned that match a given query.</span>
<span class="sd">    Then each time series is read and some processing is applied.</span>

<span class="sd">    Note: Mesh does not yet handle parallel requests, every request is handled</span>
<span class="sd">          sequentially.</span>

<span class="sd">    This example works with `SimpleThermalTestModel` test model, where 2 time</span>
<span class="sd">    series are returned for the given query. Assume reading time series takes</span>
<span class="sd">    10 seconds and processing (or some different computation, e.g.</span>
<span class="sd">    neural network inference based on that input) takes 8 seconds.</span>
<span class="sd">    When waiting for the read operation to complete for the second time series</span>
<span class="sd">    we can already start processing the first time series. See:</span>

<span class="sd">    Tr = 10s (reading)</span>
<span class="sd">    Tp = 8s  (processing)</span>

<span class="sd">    Asynchronous code (with Mesh handling requests sequentially):</span>
<span class="sd">    |   Tr1  ||  Tp1 |</span>
<span class="sd">    ------------------</span>
<span class="sd">              |   Tr2  ||  Tp2 |</span>
<span class="sd">              ------------------</span>
<span class="sd">    ---------- 28s -------------</span>

<span class="sd">    Whereas for synchronous code:</span>
<span class="sd">    |   Tr1  ||  Tp1 |</span>
<span class="sd">    ------------------</span>
<span class="sd">                      |   Tr2  ||  Tp2 |</span>
<span class="sd">                      ------------------</span>
<span class="sd">    ---------------  36s ---------------</span>

<span class="sd">    For 2 time series we save ~22% time.</span>
<span class="sd">    For 10 time series it would be 40% time (108s instead of 180s).</span>

<span class="sd">    Note: the processing could be also done using async IO</span>
<span class="sd">          (e.g. requests send to different service).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">query</span> <span class="o">=</span> <span class="s2">&quot;*.TsRawAtt&quot;</span>
    <span class="n">start_object_path</span> <span class="o">=</span> <span class="s2">&quot;Model/SimpleThermalTestModel/ThermalComponent&quot;</span>

    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = Connection.with_tls(address, tls_root_pem_cert)</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">timeseries_attributes</span> <span class="o">=</span> <span class="k">await</span> <span class="n">session</span><span class="o">.</span><span class="n">search_for_timeseries_attributes</span><span class="p">(</span>
                <span class="n">target</span><span class="o">=</span><span class="n">start_object_path</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="n">query</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="n">grpc</span><span class="o">.</span><span class="n">RpcError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not find timeseries attribute: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of found time series: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">timeseries_attributes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
            <span class="o">*</span><span class="p">(</span>
                <span class="n">handle_timeseries</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">timeseries_attribute</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">timeseries_attribute</span> <span class="ow">in</span> <span class="n">timeseries_attributes</span>
            <span class="p">)</span>
        <span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">get_connection_info</span><span class="p">()</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="search-for-time-series-attributes">
<h2>Search for time series attributes<a class="headerlink" href="#search-for-time-series-attributes" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">helpers</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">volue.mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">Connection</span><span class="p">,</span> <span class="n">OwnershipRelationAttribute</span><span class="p">,</span> <span class="n">TimeseriesAttribute</span>


<span class="k">def</span><span class="w"> </span><span class="nf">search_method_1</span><span class="p">(</span><span class="n">session</span><span class="p">:</span> <span class="n">Connection</span><span class="o">.</span><span class="n">Session</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method uses `search_for_timeseries_attributes` function.</span>
<span class="sd">    Wildcard search expression for attributes is not supported, meaning we</span>
<span class="sd">    can&#39;t get all time series attributes using simply &quot;*&quot; search expression.</span>

<span class="sd">    Useful e.g.: when searching for attributes with known names.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Search method 1&quot;</span><span class="p">)</span>

    <span class="c1"># Specify what you want to search for</span>

    <span class="c1"># The Mesh object to start searching from</span>
    <span class="n">start_object_path</span> <span class="o">=</span> <span class="s2">&quot;Model/SimpleThermalTestModel/ThermalComponent&quot;</span>
    <span class="c1"># OR</span>
    <span class="c1"># start_object_guid = uuid.UUID(&quot;0000000b-0001-0000-0000-000000000000&quot;)  # ThermalComponent</span>

    <span class="c1"># The query expressed using Mesh search language syntax</span>
    <span class="c1"># Traverse all children ({*}) of the start object and accept all that have</span>
    <span class="c1"># an attribute (.) called TsRawAtt</span>
    <span class="n">query</span> <span class="o">=</span> <span class="s2">&quot;{*}.TsRawAtt&quot;</span>

    <span class="c1"># Search for time series attributes using this query</span>
    <span class="n">timeseries_attributes</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">search_for_timeseries_attributes</span><span class="p">(</span>
        <span class="n">target</span><span class="o">=</span><span class="n">start_object_path</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="n">query</span>
    <span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of found time series: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">timeseries_attributes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="n">timeseries_attributes</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="n">TimeseriesAttribute</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">attribute</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">search_method_2</span><span class="p">(</span><span class="n">session</span><span class="p">:</span> <span class="n">Connection</span><span class="o">.</span><span class="n">Session</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method uses `search_for_objects` function with wildcard search</span>
<span class="sd">    expression (&quot;*&quot;) that returns all objects.</span>
<span class="sd">    Useful when you want to traverse the complete model.</span>

<span class="sd">    Additionally here we show how to distinguish if time series attribute has</span>
<span class="sd">    a time series calculation expression defined or a physical time series</span>
<span class="sd">    connected to it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Search method 2&quot;</span><span class="p">)</span>

    <span class="c1"># Provide root object/model as the start object to run the search.</span>
    <span class="c1"># Root objects/models do not contain any attributes.</span>
    <span class="n">start_object_path</span> <span class="o">=</span> <span class="s2">&quot;Model/SimpleThermalTestModel&quot;</span>

    <span class="c1"># Returns every object.</span>
    <span class="n">query</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span>

    <span class="c1"># Depending on the model size this may take long time to complete.</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">search_for_objects</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">start_object_path</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="n">query</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of found objects: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="nb">object</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">object</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="nb">object</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="n">TimeseriesAttribute</span><span class="p">):</span>
                <span class="c1"># If time series resource is set, then it means a physical</span>
                <span class="c1"># time series is connected to the attribute.</span>
                <span class="k">if</span> <span class="n">attribute</span><span class="o">.</span><span class="n">time_series_resource</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attribute</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2"> has physical time series connected with time series key </span><span class="si">{</span><span class="n">attribute</span><span class="o">.</span><span class="n">time_series_resource</span><span class="o">.</span><span class="n">timeseries_key</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">search_method_3</span><span class="p">(</span><span class="n">session</span><span class="p">:</span> <span class="n">Connection</span><span class="o">.</span><span class="n">Session</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method uses `get_object` function.</span>
<span class="sd">    Useful when you want to traverse a subset of the model from a given node,</span>
<span class="sd">    but not root object/model. Models do not contain attributes, so you won&#39;t</span>
<span class="sd">    be able to traverse the child objects using ownership attributes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Search method 3&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">traverse_child_objects</span><span class="p">(</span><span class="n">session</span><span class="p">:</span> <span class="n">Connection</span><span class="o">.</span><span class="n">Session</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="nb">object</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">full_attribute_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="nb">object</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="n">OwnershipRelationAttribute</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">child_id</span> <span class="ow">in</span> <span class="n">attribute</span><span class="o">.</span><span class="n">target_object_ids</span><span class="p">:</span>
                    <span class="n">traverse_child_objects</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">child_id</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="n">TimeseriesAttribute</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">attribute</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

    <span class="n">object_path</span> <span class="o">=</span> <span class="s2">&quot;Model/SimpleThermalTestModel/ThermalComponent/SomePowerPlant1&quot;</span>
    <span class="n">traverse_child_objects</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">object_path</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Showing how to search for Mesh time series attributes in various ways.&quot;&quot;&quot;</span>

    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = Connection.with_tls(address, tls_root_pem_cert)</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

    <span class="c1"># Create a remote session on the Volue Mesh server.</span>
    <span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="n">search_method_1</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>
        <span class="n">search_method_2</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>
        <span class="n">search_method_3</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">get_connection_info</span><span class="p">()</span>
    <span class="n">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="traverse-model">
<h2>Traverse model<a class="headerlink" href="#traverse-model" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">helpers</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">volue.mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">Connection</span><span class="p">,</span> <span class="n">OwnershipRelationAttribute</span>

<span class="n">leaves</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">traverse_model_top_down</span><span class="p">(</span><span class="n">session</span><span class="p">:</span> <span class="n">Connection</span><span class="o">.</span><span class="n">Session</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Traverses the Mesh model recursively.&quot;&quot;&quot;</span>
    <span class="nb">object</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;..&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">depth</span><span class="si">}{</span><span class="nb">object</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">leaf</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">object</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">OwnershipRelationAttribute</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">child_id</span> <span class="ow">in</span> <span class="n">attr</span><span class="o">.</span><span class="n">target_object_ids</span><span class="p">:</span>
                <span class="n">leaf</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">traverse_model_top_down</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">child_id</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">leaf</span><span class="p">:</span>
        <span class="n">leaves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">traverse_model_bottom_up</span><span class="p">(</span><span class="n">session</span><span class="p">:</span> <span class="n">Connection</span><span class="o">.</span><span class="n">Session</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
    <span class="nb">object</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;..&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">depth</span><span class="si">}{</span><span class="nb">object</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">object</span><span class="o">.</span><span class="n">owner_id</span> <span class="o">==</span> <span class="n">model</span><span class="o">.</span><span class="n">id</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">attribute</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="nb">object</span><span class="o">.</span><span class="n">owner_id</span><span class="p">)</span>
    <span class="n">traverse_model_bottom_up</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">attribute</span><span class="o">.</span><span class="n">owner_id</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Showing how to traverse Mesh model.&quot;&quot;&quot;</span>

    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = Connection.with_tls(address, tls_root_pem_cert)</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="n">models</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">list_models</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
            <span class="n">leaves</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Model: &#39;</span><span class="si">{</span><span class="n">model</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Top-bottom traversal:&quot;</span><span class="p">)</span>
            <span class="n">traverse_model_top_down</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
            <span class="c1"># Excepted output:</span>
            <span class="c1"># Model</span>
            <span class="c1"># ..ChildObject1</span>
            <span class="c1"># ....SubChildObject1</span>
            <span class="c1"># ....SubChildObject2</span>
            <span class="c1"># ..ChildObject2</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Bottom-top traversal:&quot;</span><span class="p">)</span>
            <span class="n">traverse_model_bottom_up</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">leaves</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
            <span class="c1"># Excepted output:</span>
            <span class="c1"># ....SubChildObject1</span>
            <span class="c1"># ..ChildObject1</span>
            <span class="c1"># Model</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">get_connection_info</span><span class="p">()</span>
    <span class="n">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="using-time-series-with-pandas">
<h2>Using time series with pandas<a class="headerlink" href="#using-time-series-with-pandas" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">grpc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">helpers</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pyarrow</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pa</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dateutil</span><span class="w"> </span><span class="kn">import</span> <span class="n">tz</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">volue.mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">Connection</span><span class="p">,</span> <span class="n">Timeseries</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">volue.mesh.calc</span><span class="w"> </span><span class="kn">import</span> <span class="n">transform</span> <span class="k">as</span> <span class="n">Transform</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">volue.mesh.calc.common</span><span class="w"> </span><span class="kn">import</span> <span class="n">Timezone</span>


<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Showing how to find time series, write, read points from it and convert them to pandas format.&quot;&quot;&quot;</span>

    <span class="n">query</span> <span class="o">=</span> <span class="s2">&quot;*[.Name=SomePowerPlantChimney2].TsRawAtt&quot;</span>  <span class="c1"># make sure only 1 time series is returned</span>
    <span class="n">start_object_path</span> <span class="o">=</span> <span class="s2">&quot;Model/SimpleThermalTestModel/ThermalComponent&quot;</span>

    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = Connection.with_tls(address, tls_root_pem_cert)</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="c1"># first lets find a time series in our model</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">timeseries_attributes</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">search_for_timeseries_attributes</span><span class="p">(</span>
                <span class="n">start_object_path</span><span class="p">,</span> <span class="n">query</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="n">grpc</span><span class="o">.</span><span class="n">RpcError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not find time series attribute: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">timeseries_attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No such time series attribute in the given model/database&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of found time series: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">timeseries_attributes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># pick the first time series and do some operations with it</span>
        <span class="n">timeseries_attribute</span> <span class="o">=</span> <span class="n">timeseries_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Working on timeseries with path: &quot;</span> <span class="o">+</span> <span class="n">timeseries_attribute</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

        <span class="c1"># check for example the curve type of the connected physical time series</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Curve: </span><span class="si">{</span><span class="n">timeseries_attribute</span><span class="o">.</span><span class="n">time_series_resource</span><span class="o">.</span><span class="n">curve_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># now lets write some data to it</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Mesh data is organized as an Arrow table with the following schema:</span>
            <span class="c1"># utc_time - [pa.timestamp(&#39;ms&#39;)] as a UTC Unix timestamp expressed in milliseconds</span>
            <span class="c1"># flags - [pa.uint32]</span>
            <span class="c1"># value - [pa.float64]</span>

            <span class="n">number_of_points</span> <span class="o">=</span> <span class="mi">72</span>
            <span class="n">timestamps</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">number_of_points</span><span class="p">):</span>
                <span class="n">hours</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">24</span>
                <span class="n">days</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">24</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">timestamps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">days</span><span class="p">,</span> <span class="n">hours</span><span class="p">)</span>
                <span class="p">)</span>  <span class="c1"># if no time zone is provided then the timestamp is treated as UTC</span>
                <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">days</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>

            <span class="n">flags</span> <span class="o">=</span> <span class="p">[</span><span class="n">Timeseries</span><span class="o">.</span><span class="n">PointFlags</span><span class="o">.</span><span class="n">OK</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_points</span>

            <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">timestamps</span><span class="p">),</span> <span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">flags</span><span class="p">),</span> <span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)]</span>
            <span class="n">arrow_table</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">Table</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">Timeseries</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span>

            <span class="n">timeseries</span> <span class="o">=</span> <span class="n">Timeseries</span><span class="p">(</span>
                <span class="n">table</span><span class="o">=</span><span class="n">arrow_table</span><span class="p">,</span> <span class="n">full_name</span><span class="o">=</span><span class="n">timeseries_attribute</span><span class="o">.</span><span class="n">path</span>
            <span class="p">)</span>
            <span class="n">session</span><span class="o">.</span><span class="n">write_timeseries_points</span><span class="p">(</span><span class="n">timeseries</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">grpc</span><span class="o">.</span><span class="n">RpcError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not write timeseries points: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">local_time_zone</span> <span class="o">=</span> <span class="n">tz</span><span class="o">.</span><span class="n">tzlocal</span><span class="p">()</span>

        <span class="c1"># now lets read from it</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># lets use local time zone (read from operating system settings)</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">local_time_zone</span><span class="p">)</span>
            <span class="n">end_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">local_time_zone</span><span class="p">)</span>

            <span class="n">timeseries_read</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">read_timeseries_points</span><span class="p">(</span>
                <span class="n">target</span><span class="o">=</span><span class="n">timeseries_attribute</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="n">end_time</span>
            <span class="p">)</span>

            <span class="c1"># convert to pandas format</span>
            <span class="c1"># the timestamps in PyArrow table are always returned in UTC format</span>
            <span class="n">pandas_series</span> <span class="o">=</span> <span class="n">timeseries_read</span><span class="o">.</span><span class="n">arrow_table</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>

            <span class="c1"># lets convert it back to local time zone</span>
            <span class="c1"># first convert to UTC time zone aware datetime object and then to local time zone (set in operating system)</span>
            <span class="n">pandas_series</span><span class="p">[</span><span class="s2">&quot;utc_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
                <span class="n">pandas_series</span><span class="p">[</span><span class="s2">&quot;utc_time&quot;</span><span class="p">],</span> <span class="n">utc</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="n">local_time_zone</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">pandas_series</span><span class="p">)</span>

            <span class="c1"># notice that depending on the local time zone there is a shift in the data</span>
            <span class="c1"># e.g. for UTC+2 time zone, first 2 values will be NaN, because writing time series points in the previous step</span>
            <span class="c1"># is using time zone naive datetime object, so they are treated as UTC.</span>

            <span class="c1"># do some further processing</span>

        <span class="k">except</span> <span class="n">grpc</span><span class="o">.</span><span class="n">RpcError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not read timeseries points: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># now lets read transformations from it (transform to days)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Transform resolution to days:&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">local_time_zone</span><span class="p">)</span>
            <span class="n">end_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">local_time_zone</span><span class="p">)</span>

            <span class="c1"># Transform function may take optionally a time zone argument.</span>
            <span class="c1"># Refer to `transform` documentation for more details.</span>
            <span class="c1"># If you are using `LOCAL` or `STANDARD` time zone then make sure</span>
            <span class="c1"># the Mesh server is operating in the same time zone or adjust properly.</span>
            <span class="n">transformed_timeseries</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">transform_functions</span><span class="p">(</span>
                <span class="n">timeseries_attribute</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span>
            <span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">Timeseries</span><span class="o">.</span><span class="n">Resolution</span><span class="o">.</span><span class="n">DAY</span><span class="p">,</span> <span class="n">Transform</span><span class="o">.</span><span class="n">Method</span><span class="o">.</span><span class="n">SUM</span><span class="p">,</span> <span class="n">Timezone</span><span class="o">.</span><span class="n">LOCAL</span><span class="p">)</span>

            <span class="c1"># convert to pandas format</span>
            <span class="c1"># the timestamps in PyArrow table are always returned in UTC format</span>
            <span class="n">pandas_series</span> <span class="o">=</span> <span class="n">transformed_timeseries</span><span class="o">.</span><span class="n">arrow_table</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">pandas_series</span><span class="p">)</span>

            <span class="c1"># lets convert it back to local time zone</span>
            <span class="c1"># first convert to UTC time zone aware datetime object and then to local time zone (set in operating system)</span>
            <span class="n">pandas_series</span><span class="p">[</span><span class="s2">&quot;utc_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
                <span class="n">pandas_series</span><span class="p">[</span><span class="s2">&quot;utc_time&quot;</span><span class="p">],</span> <span class="n">utc</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="n">local_time_zone</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">pandas_series</span><span class="p">)</span>

            <span class="c1"># do some further processing</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not read transformed timeseries points: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># optionally discard changes</span>
        <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># This will search for a given time series, write some data,</span>
    <span class="c1"># read it and convert to pandas format.</span>

    <span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">get_connection_info</span><span class="p">()</span>
    <span class="n">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="working-with-link-relations">
<h2>Working with link relations<a class="headerlink" href="#working-with-link-relations" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">helpers</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dateutil</span><span class="w"> </span><span class="kn">import</span> <span class="n">tz</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">volue.mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">Connection</span><span class="p">,</span> <span class="n">LinkRelationVersion</span><span class="p">,</span> <span class="n">VersionedLinkRelationAttribute</span>

<span class="n">OBJECT_PATH</span> <span class="o">=</span> <span class="s2">&quot;Model/SimpleThermalTestModel/ThermalComponent.ThermalPowerToPlantRef/SomePowerPlant1&quot;</span>
<span class="n">ONE_TO_ONE_PATH</span> <span class="o">=</span> <span class="n">OBJECT_PATH</span> <span class="o">+</span> <span class="s2">&quot;.SimpleReference&quot;</span>
<span class="n">ONE_TO_MANY_PATH</span> <span class="o">=</span> <span class="n">OBJECT_PATH</span> <span class="o">+</span> <span class="s2">&quot;.PlantToChimneyRefCollection&quot;</span>
<span class="n">VERSIONED_ONE_TO_ONE_PATH</span> <span class="o">=</span> <span class="n">OBJECT_PATH</span> <span class="o">+</span> <span class="s2">&quot;.ReferenceSeriesAtt&quot;</span>
<span class="n">VERSIONED_ONE_TO_MANY_PATH</span> <span class="o">=</span> <span class="n">OBJECT_PATH</span> <span class="o">+</span> <span class="s2">&quot;.ReferenceSeriesCollectionAtt&quot;</span>


<span class="n">LOCAL_TIME_ZONE</span> <span class="o">=</span> <span class="n">tz</span><span class="o">.</span><span class="n">tzlocal</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">one_to_one_link_relation_example</span><span class="p">(</span><span class="n">session</span><span class="p">:</span> <span class="n">Connection</span><span class="o">.</span><span class="n">Session</span><span class="p">):</span>
    <span class="n">attribute_path</span> <span class="o">=</span> <span class="n">ONE_TO_ONE_PATH</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">One-to-one link relation&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;------------------------&quot;</span><span class="p">)</span>

    <span class="c1"># First read the attribute using `get_attribute`.</span>
    <span class="c1"># Full attribute information is needed to get target object type name.</span>
    <span class="n">attribute</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">attribute_path</span><span class="p">,</span> <span class="n">full_attribute_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Link relation attribute points to </span><span class="si">{</span><span class="n">attribute</span><span class="o">.</span><span class="n">target_object_ids</span><span class="si">}</span><span class="s2"> of type </span><span class="si">{</span><span class="n">attribute</span><span class="o">.</span><span class="n">definition</span><span class="o">.</span><span class="n">target_object_type_name</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Get more information on the target object the link relation points to.</span>
    <span class="c1"># The link relation can be potentially nullable,check if there is any</span>
    <span class="c1"># target object the link relation points to.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attribute</span><span class="o">.</span><span class="n">target_object_ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">target_object</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">attribute</span><span class="o">.</span><span class="n">target_object_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Target object path is: </span><span class="si">{</span><span class="n">target_object</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Change the target object.</span>
    <span class="n">new_target_object_path</span> <span class="o">=</span> <span class="n">OBJECT_PATH</span> <span class="o">+</span> <span class="s2">&quot;.PlantToChimneyRef/SomePowerPlantChimney1&quot;</span>
    <span class="n">new_target_object</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">new_target_object_path</span><span class="p">)</span>
    <span class="n">session</span><span class="o">.</span><span class="n">update_link_relation_attribute</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="p">[</span><span class="n">new_target_object</span><span class="o">.</span><span class="n">id</span><span class="p">])</span>

    <span class="c1"># Read the updated attribute.</span>
    <span class="n">attribute</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">attribute_path</span><span class="p">,</span> <span class="n">full_attribute_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Updated link relation attribute points to </span><span class="si">{</span><span class="n">attribute</span><span class="o">.</span><span class="n">target_object_ids</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">one_to_many_link_relation_example</span><span class="p">(</span><span class="n">session</span><span class="p">:</span> <span class="n">Connection</span><span class="o">.</span><span class="n">Session</span><span class="p">):</span>
    <span class="n">attribute_path</span> <span class="o">=</span> <span class="n">ONE_TO_MANY_PATH</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">One-to-many link relation&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-------------------------&quot;</span><span class="p">)</span>

    <span class="c1"># First read the attribute using `get_attribute`.</span>
    <span class="c1"># Full attribute information is needed to get target object type name.</span>
    <span class="n">attribute</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">attribute_path</span><span class="p">,</span> <span class="n">full_attribute_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Link relation attribute points to </span><span class="si">{</span><span class="n">attribute</span><span class="o">.</span><span class="n">target_object_ids</span><span class="si">}</span><span class="s2"> of type </span><span class="si">{</span><span class="n">attribute</span><span class="o">.</span><span class="n">definition</span><span class="o">.</span><span class="n">target_object_type_name</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Get more information on the target object the link relation points to.</span>
    <span class="c1"># The link relation can be potentially nullable,check if there is any</span>
    <span class="c1"># target object the link relation points to.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Target object paths:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">target_object_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">attribute</span><span class="o">.</span><span class="n">target_object_ids</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">target_object</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">target_object_id</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">target_object</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Remove all target objects.</span>
    <span class="n">session</span><span class="o">.</span><span class="n">update_link_relation_attribute</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="p">[])</span>

    <span class="c1"># Read the updated attribute.</span>
    <span class="n">attribute</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">attribute_path</span><span class="p">,</span> <span class="n">full_attribute_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Updated link relation attribute points to </span><span class="si">{</span><span class="n">attribute</span><span class="o">.</span><span class="n">target_object_ids</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Find target object for the new version.</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">search_for_objects</span><span class="p">(</span>
        <span class="s2">&quot;Model/SimpleThermalTestModel&quot;</span><span class="p">,</span>
        <span class="n">query</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;*[.Type=</span><span class="si">{</span><span class="n">attribute</span><span class="o">.</span><span class="n">definition</span><span class="o">.</span><span class="n">target_object_type_name</span><span class="si">}</span><span class="s2">&amp;&amp;.Name=SomePowerPlantChimney1]&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;invalid result from &#39;search_for_objects&#39;, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;expected 1 target object, but got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="n">new_target_object_1</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Set a new target object.</span>
    <span class="c1"># Updating one-to-many link relation without setting `append` flag will</span>
    <span class="c1"># replace all already existing target objects with the new ones.</span>
    <span class="n">session</span><span class="o">.</span><span class="n">update_link_relation_attribute</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="p">[</span><span class="n">new_target_object_1</span><span class="o">.</span><span class="n">id</span><span class="p">])</span>

    <span class="c1"># Add a new target object.</span>
    <span class="c1"># Now use `append` flag to preserve already existing target objects.</span>
    <span class="n">new_target_object_2_path</span> <span class="o">=</span> <span class="n">OBJECT_PATH</span> <span class="o">+</span> <span class="s2">&quot;.PlantToChimneyRef/SomePowerPlantChimney2&quot;</span>
    <span class="n">new_target_object_2</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">new_target_object_2_path</span><span class="p">)</span>
    <span class="n">session</span><span class="o">.</span><span class="n">update_link_relation_attribute</span><span class="p">(</span>
        <span class="n">attribute</span><span class="p">,</span> <span class="p">[</span><span class="n">new_target_object_2</span><span class="o">.</span><span class="n">id</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="c1"># Read the updated attribute.</span>
    <span class="n">attribute</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">attribute_path</span><span class="p">,</span> <span class="n">full_attribute_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Updated link relation attribute points to </span><span class="si">{</span><span class="n">attribute</span><span class="o">.</span><span class="n">target_object_ids</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_versioned_link_relation_attribute_information</span><span class="p">(</span>
    <span class="n">attribute</span><span class="p">:</span> <span class="n">VersionedLinkRelationAttribute</span><span class="p">,</span> <span class="n">session</span><span class="p">:</span> <span class="n">Connection</span><span class="o">.</span><span class="n">Session</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a printable message from a versioned link relation attribute.&quot;&quot;&quot;</span>
    <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="k">for</span> <span class="n">entry_index</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">attribute</span><span class="o">.</span><span class="n">entries</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Entry </span><span class="si">{</span><span class="n">entry_index</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">version_index</span><span class="p">,</span> <span class="n">version</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">versions</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">version</span><span class="o">.</span><span class="n">target_object_id</span><span class="p">:</span>
                <span class="n">target_object</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">version</span><span class="o">.</span><span class="n">target_object_id</span><span class="p">)</span>
                <span class="n">target_object_name</span> <span class="o">=</span> <span class="n">target_object</span><span class="o">.</span><span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">target_object_name</span> <span class="o">=</span> <span class="s2">&quot;&lt;EMPTY&gt;&quot;</span>

            <span class="n">valid_from_time_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="c1"># If running on Windows and the datetime is before epoch</span>
            <span class="c1"># (1.1.1970 UTC) then we can&#39;t use `astimezone` because Windows</span>
            <span class="c1"># `localtime()` does not support it, see discussion:</span>
            <span class="c1"># https://bugs.python.org/issue31327</span>
            <span class="k">if</span> <span class="n">version</span><span class="o">.</span><span class="n">valid_from_time</span> <span class="o">&lt;</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">1970</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">tz</span><span class="o">.</span><span class="n">UTC</span><span class="p">):</span>
                <span class="c1"># If the datetime is before 1.1.1970 UTC then print the time</span>
                <span class="c1"># zone info.</span>
                <span class="n">valid_from_time_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">version</span><span class="o">.</span><span class="n">valid_from_time</span><span class="si">:</span><span class="s2">%Y-%m-%dT%H:%M:%S %Z</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise convert to local time zone</span>
                <span class="n">valid_from_time_str</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">version</span><span class="o">.</span><span class="n">valid_from_time</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">LOCAL_TIME_ZONE</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Version </span><span class="si">{</span><span class="n">version_index</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;target object name: </span><span class="si">{</span><span class="n">target_object_name</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;valid from time: </span><span class="si">{</span><span class="n">valid_from_time_str</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">message</span>


<span class="k">def</span><span class="w"> </span><span class="nf">versioned_one_to_one_link_relation_example</span><span class="p">(</span><span class="n">session</span><span class="p">:</span> <span class="n">Connection</span><span class="o">.</span><span class="n">Session</span><span class="p">):</span>
    <span class="n">attribute_path</span> <span class="o">=</span> <span class="n">VERSIONED_ONE_TO_ONE_PATH</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Versioned one-to-one link relation&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;----------------------------------&quot;</span><span class="p">)</span>

    <span class="n">attribute</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">attribute_path</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">get_versioned_link_relation_attribute_information</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="n">session</span><span class="p">))</span>

    <span class="c1"># Remove the first version in entry.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attribute</span><span class="o">.</span><span class="n">entries</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">attribute</span><span class="o">.</span><span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">versions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">session</span><span class="o">.</span><span class="n">update_versioned_one_to_one_link_relation_attribute</span><span class="p">(</span>
            <span class="n">attribute_path</span><span class="p">,</span>
            <span class="n">start_time</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">min</span><span class="p">,</span>
            <span class="c1"># Replacement interval end time is exclusive,</span>
            <span class="c1"># i.e.: [start_time, end_time).</span>
            <span class="c1"># That is why we need to add some small time fraction to make</span>
            <span class="c1"># sure the last version&#39;s `valid_from_time` is within the</span>
            <span class="c1"># replacement interval.</span>
            <span class="n">end_time</span><span class="o">=</span><span class="n">attribute</span><span class="o">.</span><span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">versions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">valid_from_time</span>
            <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">microseconds</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">new_versions</span><span class="o">=</span><span class="p">[],</span>
        <span class="p">)</span>

    <span class="c1"># Add a new version in entry.</span>
    <span class="n">new_target_object_path</span> <span class="o">=</span> <span class="n">OBJECT_PATH</span> <span class="o">+</span> <span class="s2">&quot;.PlantToChimneyRef/SomePowerPlantChimney1&quot;</span>
    <span class="n">new_target_object</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">new_target_object_path</span><span class="p">)</span>
    <span class="n">new_link_relation_version_1</span> <span class="o">=</span> <span class="n">LinkRelationVersion</span><span class="p">(</span>
        <span class="n">target_object_id</span><span class="o">=</span><span class="n">new_target_object</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
        <span class="c1"># If no time zone is provided then it will be treated as UTC.</span>
        <span class="n">valid_from_time</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2022</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">LOCAL_TIME_ZONE</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="c1"># Add another one, this this with empty target object.</span>
    <span class="n">new_link_relation_version_2</span> <span class="o">=</span> <span class="n">LinkRelationVersion</span><span class="p">(</span>
        <span class="n">target_object_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="c1"># If no time zone is provided then it will be treated as UTC.</span>
        <span class="n">valid_from_time</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2025</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">LOCAL_TIME_ZONE</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="n">session</span><span class="o">.</span><span class="n">update_versioned_one_to_one_link_relation_attribute</span><span class="p">(</span>
        <span class="n">attribute_path</span><span class="p">,</span>
        <span class="n">start_time</span><span class="o">=</span><span class="n">new_link_relation_version_1</span><span class="o">.</span><span class="n">valid_from_time</span><span class="p">,</span>
        <span class="n">end_time</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>
        <span class="n">new_versions</span><span class="o">=</span><span class="p">[</span><span class="n">new_link_relation_version_1</span><span class="p">,</span> <span class="n">new_link_relation_version_2</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="c1"># Read the updated attribute.</span>
    <span class="n">attribute</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">attribute_path</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updated link relation attribute:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">get_versioned_link_relation_attribute_information</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="n">session</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">versioned_one_to_many_link_relation_example</span><span class="p">(</span><span class="n">session</span><span class="p">:</span> <span class="n">Connection</span><span class="o">.</span><span class="n">Session</span><span class="p">):</span>
    <span class="n">attribute_path</span> <span class="o">=</span> <span class="n">VERSIONED_ONE_TO_MANY_PATH</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Versioned one-to-many link relation&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-----------------------------------&quot;</span><span class="p">)</span>

    <span class="n">attribute</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">attribute_path</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">get_versioned_link_relation_attribute_information</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="n">session</span><span class="p">))</span>

    <span class="n">new_target_object_1_path</span> <span class="o">=</span> <span class="n">OBJECT_PATH</span> <span class="o">+</span> <span class="s2">&quot;.PlantToChimneyRef/SomePowerPlantChimney1&quot;</span>
    <span class="n">new_target_object_1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">new_target_object_1_path</span><span class="p">)</span>

    <span class="n">new_target_object_2_path</span> <span class="o">=</span> <span class="n">OBJECT_PATH</span> <span class="o">+</span> <span class="s2">&quot;.PlantToChimneyRef/SomePowerPlantChimney2&quot;</span>
    <span class="n">new_target_object_2</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">new_target_object_2_path</span><span class="p">)</span>

    <span class="n">entry_1_version_1</span> <span class="o">=</span> <span class="n">LinkRelationVersion</span><span class="p">(</span>
        <span class="n">target_object_id</span><span class="o">=</span><span class="n">new_target_object_1</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
        <span class="c1"># If no time zone is provided then it will be treated as UTC.</span>
        <span class="n">valid_from_time</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2022</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">LOCAL_TIME_ZONE</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">entry_1_version_2</span> <span class="o">=</span> <span class="n">LinkRelationVersion</span><span class="p">(</span>
        <span class="n">target_object_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="c1"># If no time zone is provided then it will be treated as UTC.</span>
        <span class="n">valid_from_time</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2025</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">LOCAL_TIME_ZONE</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">entry_1_version_3</span> <span class="o">=</span> <span class="n">LinkRelationVersion</span><span class="p">(</span>
        <span class="n">target_object_id</span><span class="o">=</span><span class="n">new_target_object_1</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
        <span class="c1"># If no time zone is provided then it will be treated as UTC.</span>
        <span class="n">valid_from_time</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2027</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">LOCAL_TIME_ZONE</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">entry1</span> <span class="o">=</span> <span class="p">[</span><span class="n">entry_1_version_1</span><span class="p">,</span> <span class="n">entry_1_version_2</span><span class="p">,</span> <span class="n">entry_1_version_3</span><span class="p">]</span>

    <span class="n">entry_2_version_1</span> <span class="o">=</span> <span class="n">LinkRelationVersion</span><span class="p">(</span>
        <span class="n">target_object_id</span><span class="o">=</span><span class="n">new_target_object_2</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
        <span class="n">valid_from_time</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">entry_2_version_2</span> <span class="o">=</span> <span class="n">LinkRelationVersion</span><span class="p">(</span>
        <span class="n">target_object_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">valid_from_time</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2010</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">entry2</span> <span class="o">=</span> <span class="p">[</span><span class="n">entry_2_version_1</span><span class="p">,</span> <span class="n">entry_2_version_2</span><span class="p">]</span>

    <span class="n">new_entries</span> <span class="o">=</span> <span class="p">[</span><span class="n">entry1</span><span class="p">,</span> <span class="n">entry2</span><span class="p">]</span>
    <span class="n">session</span><span class="o">.</span><span class="n">update_versioned_one_to_many_link_relation_attribute</span><span class="p">(</span>
        <span class="n">attribute_path</span><span class="p">,</span> <span class="n">new_entries</span>
    <span class="p">)</span>

    <span class="c1"># Read the updated attribute.</span>
    <span class="n">attribute</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">attribute_path</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updated link relation attribute:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">get_versioned_link_relation_attribute_information</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="n">session</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = Connection.with_tls(address, tls_root_pem_cert)</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="n">one_to_one_link_relation_example</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>
        <span class="n">one_to_many_link_relation_example</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>
        <span class="n">versioned_one_to_one_link_relation_example</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>
        <span class="n">versioned_one_to_many_link_relation_example</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>

        <span class="c1"># to commit your changes you need to call:</span>
        <span class="c1"># session.commit()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">get_connection_info</span><span class="p">()</span>
    <span class="n">main</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="working-with-model-objects-and-attributes">
<h2>Working with model (objects and attributes)<a class="headerlink" href="#working-with-model-objects-and-attributes" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">helpers</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">volue.mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">AttributesFilter</span><span class="p">,</span> <span class="n">Connection</span><span class="p">,</span> <span class="n">OwnershipRelationAttribute</span>


<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
    <span class="n">root_object_path</span> <span class="o">=</span> <span class="s2">&quot;Model/SimpleThermalTestModel/ThermalComponent&quot;</span>

    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = Connection.with_tls(address, tls_root_pem_cert)</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="c1"># Root object has an ownership relation attribute that point to objects</span>
        <span class="c1"># of &quot;PlantElementType&quot; type. We want to add new object of this type.</span>
        <span class="n">root_object</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">root_object_path</span><span class="p">,</span> <span class="n">full_attribute_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># First get the ownership attribute:</span>
        <span class="c1"># If we know the name of the attribute we can use:</span>
        <span class="n">ownership_relation_attribute</span> <span class="o">=</span> <span class="n">root_object</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s2">&quot;ThermalPowerToPlantRef&quot;</span><span class="p">]</span>

        <span class="c1"># If we don&#39;t know the name, but only the type of the target object</span>
        <span class="c1"># (the object it points to):</span>
        <span class="c1"># Note: This requires `full_attribute_info` flag set to True when</span>
        <span class="c1">#       calling `get_object` or `get_attribute`.</span>
        <span class="k">for</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="n">root_object</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="n">OwnershipRelationAttribute</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">attribute</span><span class="o">.</span><span class="n">definition</span><span class="o">.</span><span class="n">target_object_type_name</span> <span class="o">==</span> <span class="s2">&quot;PlantElementType&quot;</span>
            <span class="p">):</span>
                <span class="n">ownership_relation_attribute</span> <span class="o">=</span> <span class="n">attribute</span>

        <span class="n">new_object</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">create_object</span><span class="p">(</span>
            <span class="n">ownership_relation_attribute</span><span class="p">,</span> <span class="s2">&quot;SomeNewPowerPlant&quot;</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New object created: </span><span class="si">{</span><span class="n">new_object</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">int_attribute</span> <span class="o">=</span> <span class="n">new_object</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s2">&quot;Int64Att&quot;</span><span class="p">]</span>

        <span class="c1"># Object returned by `create_object` contains all attributes with basic</span>
        <span class="c1"># information.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;One of the new object&#39;s attributes (basic information):&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">int_attribute</span><span class="p">)</span>

        <span class="c1"># Now let&#39;s update attribute&#39;s value.</span>
        <span class="n">session</span><span class="o">.</span><span class="n">update_simple_attribute</span><span class="p">(</span><span class="n">int_attribute</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

        <span class="c1"># Check updated value, but this time get also more information like</span>
        <span class="c1"># attribute definition. Use either:</span>
        <span class="c1"># - `get_object` with `full_attribute_info` flag</span>
        <span class="c1"># - `get_attribute` with `full_attribute_info` flag</span>
        <span class="n">attribute_with_full_info</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span>
            <span class="n">int_attribute</span><span class="p">,</span> <span class="n">full_attribute_info</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;One of the new object&#39;s attributes (full information):&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">attribute_with_full_info</span><span class="p">)</span>

        <span class="c1"># We can also filter attributes by e.g. name.</span>
        <span class="n">object_with_filtered_attributes</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span>
            <span class="n">new_object</span><span class="p">,</span>
            <span class="n">attributes_filter</span><span class="o">=</span><span class="n">AttributesFilter</span><span class="p">(</span><span class="n">name_mask</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DblAtt&quot;</span><span class="p">,</span> <span class="s2">&quot;StringAtt&quot;</span><span class="p">]),</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Filtered attributes count: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">object_with_filtered_attributes</span><span class="o">.</span><span class="n">attributes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Connect a time series resource to a time series attribute of the new object.</span>
        <span class="n">new_timeseries_resource_key</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">session</span><span class="o">.</span><span class="n">update_timeseries_attribute</span><span class="p">(</span>
            <span class="n">new_object</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s2">&quot;TsRawAtt&quot;</span><span class="p">],</span>
            <span class="n">new_timeseries_resource_key</span><span class="o">=</span><span class="n">new_timeseries_resource_key</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Now disconnect the time series resource. Set `new_timeseries_resource_key`</span>
        <span class="c1"># to 0 to disconnect.</span>
        <span class="n">session</span><span class="o">.</span><span class="n">update_timeseries_attribute</span><span class="p">(</span>
            <span class="n">new_object</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s2">&quot;TsRawAtt&quot;</span><span class="p">],</span>
            <span class="n">new_timeseries_resource_key</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Change local expression of a time series attribute of the new object.</span>
        <span class="n">new_local_expression</span> <span class="o">=</span> <span class="s2">&quot;## = 2</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">session</span><span class="o">.</span><span class="n">update_timeseries_attribute</span><span class="p">(</span>
            <span class="n">new_object</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s2">&quot;TsCalcAtt&quot;</span><span class="p">],</span>
            <span class="n">new_local_expression</span><span class="o">=</span><span class="n">new_local_expression</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Now lets change the object name.</span>
        <span class="n">session</span><span class="o">.</span><span class="n">update_object</span><span class="p">(</span><span class="n">new_object</span><span class="p">,</span> <span class="n">new_name</span><span class="o">=</span><span class="s2">&quot;NewNamePowerPlant&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Object&#39;s name changed.&quot;</span><span class="p">)</span>

        <span class="c1"># Delete the updated object.</span>
        <span class="c1"># Because we changed object&#39;s name, we can&#39;t provide old `Object`</span>
        <span class="c1"># instance as it is still having the old object name.</span>
        <span class="c1"># Use object&#39;s ID instead or provide the path to the object explicitly.</span>
        <span class="n">session</span><span class="o">.</span><span class="n">delete_object</span><span class="p">(</span><span class="n">new_object</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Object deleted.&quot;</span><span class="p">)</span>

        <span class="c1"># To commit your changes you need to call:</span>
        <span class="c1"># session.commit()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">get_connection_info</span><span class="p">()</span>
    <span class="n">main</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="working-with-rating-curves">
<h2>Working with rating curves<a class="headerlink" href="#working-with-rating-curves" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">helpers</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">volue.mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">Connection</span><span class="p">,</span> <span class="n">RatingCurveSegment</span><span class="p">,</span> <span class="n">RatingCurveVersion</span>


<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
    <span class="n">rating_curve_attribute_path</span> <span class="o">=</span> <span class="s2">&quot;Model/SimpleThermalTestModel/ThermalComponent.ThermalPowerToPlantRef/SomePowerPlant1.RatingCurveAtt&quot;</span>

    <span class="c1"># Defining a time interval to read rating curve versions from.</span>
    <span class="c1"># If no time zone is provided then it will be treated as UTC.</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2008</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2022</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = Connection.with_tls(address, tls_root_pem_cert)</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="c1"># First read the attribute using `get_attribute`.</span>
        <span class="c1"># We can get standard information like name, ID, tags, etc.</span>
        <span class="n">rating_curve_attribute</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span>
            <span class="n">rating_curve_attribute_path</span><span class="p">,</span> <span class="n">full_attribute_info</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Basic information about the rating curve attribute: </span><span class="si">{</span><span class="n">rating_curve_attribute</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Because the rating curve can potentially contain large amounts of data,</span>
        <span class="c1"># specialized methods exist to handle those values.</span>
        <span class="n">versions</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_rating_curve_versions</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="n">rating_curve_attribute_path</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="n">end_time</span>
        <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="s2">&quot;Rating curve versions for time interval: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">start_time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">.%m.%Y&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">end_time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">.%m.%Y&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">:&quot;</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">version</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">versions</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Version </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="si">{</span><span class="n">version</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">versions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">versions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">x_value_segments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No rating curve versions found. Skip update.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Now for the last version update first segment and add a new one.</span>
        <span class="n">versions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">x_value_segments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">factor_b</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.2</span>
        <span class="n">versions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">x_value_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">RatingCurveSegment</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.3</span><span class="p">))</span>
        <span class="n">session</span><span class="o">.</span><span class="n">update_rating_curve_versions</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="n">rating_curve_attribute_path</span><span class="p">,</span>
            <span class="n">start_time</span><span class="o">=</span><span class="n">versions</span><span class="p">[</span>
                <span class="mi">0</span>
            <span class="p">]</span><span class="o">.</span><span class="n">valid_from_time</span><span class="p">,</span>  <span class="c1"># use first version `valid_from_time` as start interval</span>
            <span class="n">end_time</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>  <span class="c1"># this is the last version</span>
            <span class="n">new_versions</span><span class="o">=</span><span class="n">versions</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Read once again.</span>
        <span class="n">versions</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_rating_curve_versions</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="n">rating_curve_attribute_path</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="n">end_time</span>
        <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updated rating curve versions:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">version</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">versions</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Version </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="si">{</span><span class="n">version</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Now lets replace last version with new one</span>
        <span class="n">new_segments</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">RatingCurveSegment</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.5</span><span class="p">),</span>
            <span class="n">RatingCurveSegment</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="mf">1.8</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.2</span><span class="p">),</span>
        <span class="p">]</span>

        <span class="n">new_version</span> <span class="o">=</span> <span class="n">RatingCurveVersion</span><span class="p">(</span>
            <span class="n">valid_from_time</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2010</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">x_range_from</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span>
            <span class="n">x_value_segments</span><span class="o">=</span><span class="n">new_segments</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">session</span><span class="o">.</span><span class="n">update_rating_curve_versions</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="n">rating_curve_attribute_path</span><span class="p">,</span>
            <span class="n">start_time</span><span class="o">=</span><span class="n">versions</span><span class="p">[</span>
                <span class="o">-</span><span class="mi">1</span>
            <span class="p">]</span><span class="o">.</span><span class="n">valid_from_time</span><span class="p">,</span>  <span class="c1"># to replace old version use its `valid_from_time` as start interval</span>
            <span class="n">end_time</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>  <span class="c1"># this is the last version</span>
            <span class="n">new_versions</span><span class="o">=</span><span class="p">[</span><span class="n">new_version</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># Read once again.</span>
        <span class="n">versions</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_rating_curve_versions</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="n">rating_curve_attribute_path</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="n">end_time</span>
        <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updated for the second time rating curve versions:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">version</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">versions</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Version </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="si">{</span><span class="n">version</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># to commit your changes you need to call:</span>
        <span class="c1"># session.commit()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">get_connection_info</span><span class="p">()</span>
    <span class="n">main</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="working-with-sessions">
<h2>Working with sessions<a class="headerlink" href="#working-with-sessions" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">uuid</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">helpers</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">volue.mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">Connection</span>


<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Showing different ways of working with sessions.&quot;&quot;&quot;</span>

    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = Connection.with_tls(address, tls_root_pem_cert)</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

    <span class="c1"># 1. Create a session, open and close session.</span>
    <span class="n">session</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">()</span>
    <span class="n">session</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;1. You now have a new open session&quot;</span><span class="p">)</span>
    <span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># 2. Create session using the with statement.</span>
    <span class="c1"># Session will be created, opened and closed within the &#39;with&#39; statement scope</span>
    <span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;2. You now have a new open session&quot;</span><span class="p">)</span>

    <span class="c1"># 3. Connecting to a potentially open session.</span>
    <span class="c1"># Session ids can be found in the session object:</span>
    <span class="c1"># session.session_id</span>
    <span class="c1"># Note: If the session_id is not the id of an open session,</span>
    <span class="c1"># the server will create a new one for you.</span>
    <span class="c1"># Set the session id you want to connect to</span>
    <span class="n">session_id</span> <span class="o">=</span> <span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span><span class="p">(</span><span class="s2">&quot;123e4567-e89b-12d3-a456-556642440000&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;3. Session id you want to connect to: </span><span class="si">{</span><span class="n">session_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">session</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">connect_to_session</span><span class="p">(</span><span class="n">session_id</span><span class="p">)</span>
    <span class="c1"># Try connecting to that session id, if it does not exist, a new one will be created without warning</span>
    <span class="n">session</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="s2">&quot;3. You have now an open session, either the one you requested or a new one if it did not exist&quot;</span>
    <span class="p">)</span>
    <span class="c1"># Check which session you are connected to and close it</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;3. Session id you are to connect to: </span><span class="si">{</span><span class="n">session</span><span class="o">.</span><span class="n">session_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">get_connection_info</span><span class="p">()</span>
    <span class="n">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="working-with-xy-sets">
<h2>Working with XY sets<a class="headerlink" href="#working-with-xy-sets" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">helpers</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">volue</span><span class="w"> </span><span class="kn">import</span> <span class="n">mesh</span>

<span class="n">OBJECT_PATH</span> <span class="o">=</span> <span class="s2">&quot;Model/SimpleThermalTestModel/ThermalComponent.ThermalPowerToPlantRef/SomePowerPlant1&quot;</span>
<span class="n">UNVERSIONED_PATH</span> <span class="o">=</span> <span class="n">OBJECT_PATH</span> <span class="o">+</span> <span class="s2">&quot;.XYSetAtt&quot;</span>
<span class="n">VERSIONED_PATH</span> <span class="o">=</span> <span class="n">OBJECT_PATH</span> <span class="o">+</span> <span class="s2">&quot;.XYZSeriesAtt&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = mesh.Connection.with_tls(address, tls_root_pem_cert)</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="c1"># In the default test model both the versioned and the unversioned</span>
        <span class="c1"># attribute are initially empty. The following two calls are therefore</span>
        <span class="c1"># expected to return [].</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting XY-sets from </span><span class="si">{</span><span class="n">UNVERSIONED_PATH</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">xy_sets</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_xy_sets</span><span class="p">(</span><span class="n">UNVERSIONED_PATH</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">xy_sets</span><span class="p">)</span>

        <span class="n">start_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">fromisoformat</span><span class="p">(</span><span class="s2">&quot;1960-01-01&quot;</span><span class="p">)</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">fromisoformat</span><span class="p">(</span><span class="s2">&quot;2030-01-01&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Getting XY-sets in interval [</span><span class="si">{</span><span class="n">start_time</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">end_time</span><span class="si">}</span><span class="s2">) from </span><span class="si">{</span><span class="n">VERSIONED_PATH</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">xy_sets</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_xy_sets</span><span class="p">(</span><span class="n">VERSIONED_PATH</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Received: </span><span class="si">{</span><span class="n">xy_sets</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">sample_xy_set</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">XySet</span><span class="p">(</span>
            <span class="kc">None</span><span class="p">,</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">XyCurve</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">[(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">10.3</span><span class="p">),</span> <span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">15.9</span><span class="p">)])]</span>
        <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Updating XY-set at </span><span class="si">{</span><span class="n">UNVERSIONED_PATH</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">session</span><span class="o">.</span><span class="n">update_xy_sets</span><span class="p">(</span><span class="n">UNVERSIONED_PATH</span><span class="p">,</span> <span class="n">new_xy_sets</span><span class="o">=</span><span class="p">[</span><span class="n">sample_xy_set</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updated&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Replacing XY-set versions in interval [</span><span class="si">{</span><span class="n">start_time</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">end_time</span><span class="si">}</span><span class="s2">) with one version at </span><span class="si">{</span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">sample_xy_set</span><span class="o">.</span><span class="n">valid_from_time</span> <span class="o">=</span> <span class="n">start_time</span>
        <span class="n">session</span><span class="o">.</span><span class="n">update_xy_sets</span><span class="p">(</span><span class="n">VERSIONED_PATH</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="p">[</span><span class="n">sample_xy_set</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updated&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting XY-sets from </span><span class="si">{</span><span class="n">UNVERSIONED_PATH</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">xy_sets</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_xy_sets</span><span class="p">(</span><span class="n">UNVERSIONED_PATH</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Received: </span><span class="si">{</span><span class="n">xy_sets</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Getting XY-sets in interval [</span><span class="si">{</span><span class="n">start_time</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">end_time</span><span class="si">}</span><span class="s2">) from </span><span class="si">{</span><span class="n">VERSIONED_PATH</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">xy_sets</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_xy_sets</span><span class="p">(</span><span class="n">VERSIONED_PATH</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Received: </span><span class="si">{</span><span class="n">xy_sets</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">get_connection_info</span><span class="p">()</span>
    <span class="n">main</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="write-time-series">
<h2>Write time series<a class="headerlink" href="#write-time-series" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uuid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">grpc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">helpers</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pyarrow</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pa</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dateutil</span><span class="w"> </span><span class="kn">import</span> <span class="n">tz</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">volue.mesh.aio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">volue</span><span class="w"> </span><span class="kn">import</span> <span class="n">mesh</span>

<span class="c1"># Define the time series identifier, it can be:</span>
<span class="c1"># - time series key of a physical time series</span>
<span class="c1"># - path of a time series attribute that is connected to a physical time series</span>
<span class="c1"># - ID of a time series attribute that is connected to a physical time series</span>
<span class="n">timeseries_key</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">timeseries_attribute_path</span> <span class="o">=</span> <span class="s2">&quot;Model/SimpleThermalTestModel/ThermalComponent/SomePowerPlant1/SomePowerPlantChimney2.TsRawAtt&quot;</span>
<span class="n">timeseries_attribute_id</span> <span class="o">=</span> <span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span><span class="p">(</span><span class="s2">&quot;e5df77a9-8b60-4b0a-aa1b-3c3957c538a0&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_pa_table_from_pa_arrays</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">pa</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a sample PyArrow Table with time series points from PyArrow arrays.&quot;&quot;&quot;</span>

    <span class="c1"># Defining the data we want to write.</span>
    <span class="c1"># Mesh data is organized as an Arrow table with the following schema:</span>
    <span class="c1"># utc_time - [pa.timestamp(&#39;ms&#39;)] as a UTC Unix timestamp expressed in milliseconds</span>
    <span class="c1"># flags - [pa.uint32]</span>
    <span class="c1"># value - [pa.float64]</span>

    <span class="c1"># time_zone = tz.gettz(&quot;Europe/Warsaw&quot;)</span>
    <span class="n">time_zone</span> <span class="o">=</span> <span class="n">tz</span><span class="o">.</span><span class="n">UTC</span>
    <span class="n">number_of_points</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="n">timestamps</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span>
        <span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">time_zone</span><span class="p">),</span>
        <span class="n">periods</span><span class="o">=</span><span class="n">number_of_points</span><span class="p">,</span>
        <span class="n">freq</span><span class="o">=</span><span class="s2">&quot;1h&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">Timeseries</span><span class="o">.</span><span class="n">PointFlags</span><span class="o">.</span><span class="n">OK</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_points</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">1000.0</span><span class="p">]</span>

    <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># if no time zone is provided then the timestamp is treated as UTC</span>
        <span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">timestamps</span><span class="p">),</span>
        <span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">flags</span><span class="p">),</span>
        <span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">),</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">pa</span><span class="o">.</span><span class="n">Table</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">Timeseries</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_pa_table_from_pandas</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">pa</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a sample PyArrow Table with time series points from pandas DataFrame.&quot;&quot;&quot;</span>

    <span class="c1"># Defining the data we want to write.</span>
    <span class="c1"># Mesh data is organized as an Arrow table with the following schema:</span>
    <span class="c1"># utc_time - [pa.timestamp(&#39;ms&#39;)] as a UTC Unix timestamp expressed in milliseconds</span>
    <span class="c1"># flags - [pa.uint32]</span>
    <span class="c1"># value - [pa.float64]</span>

    <span class="c1"># time_zone = tz.gettz(&quot;Europe/Warsaw&quot;)</span>
    <span class="n">time_zone</span> <span class="o">=</span> <span class="n">tz</span><span class="o">.</span><span class="n">UTC</span>
    <span class="n">number_of_points</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="n">timestamps</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span>
        <span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">time_zone</span><span class="p">),</span>
        <span class="n">periods</span><span class="o">=</span><span class="n">number_of_points</span><span class="p">,</span>
        <span class="n">freq</span><span class="o">=</span><span class="s2">&quot;1h&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">Timeseries</span><span class="o">.</span><span class="n">PointFlags</span><span class="o">.</span><span class="n">OK</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_points</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">22.2</span><span class="p">,</span> <span class="mf">333.3</span><span class="p">]</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">Timeseries</span><span class="o">.</span><span class="n">TIMESTAMP_PA_FIELD_NAME</span><span class="p">:</span> <span class="n">timestamps</span><span class="p">,</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">Timeseries</span><span class="o">.</span><span class="n">FLAGS_PA_FIELD_NAME</span><span class="p">:</span> <span class="n">flags</span><span class="p">,</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">Timeseries</span><span class="o">.</span><span class="n">VALUE_PA_FIELD_NAME</span><span class="p">:</span> <span class="n">values</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">pa</span><span class="o">.</span><span class="n">Table</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">Timeseries</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">sync_write_timeseries_points</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Synchronous write time series points:&quot;</span><span class="p">)</span>

    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = mesh.Connection.with_tls(address, tls_root_pem_cert)</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">get_pa_table_from_pandas</span><span class="p">()</span>

        <span class="c1"># Each time series point occupies 20 bytes. Mesh server has a limitation of 4MB inbound message size.</span>
        <span class="c1"># In case of larger data volumes please send input data in chunks.</span>
        <span class="c1"># E.g.: call multiple times `write_timeseries_points` with shorter interval.</span>

        <span class="c1"># Send request to write time series based on time series key.</span>
        <span class="n">timeseries</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">Timeseries</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">timskey</span><span class="o">=</span><span class="n">timeseries_key</span><span class="p">)</span>
        <span class="n">session</span><span class="o">.</span><span class="n">write_timeseries_points</span><span class="p">(</span><span class="n">timeseries</span><span class="o">=</span><span class="n">timeseries</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time series points written using time series key.&quot;</span><span class="p">)</span>

        <span class="c1"># To only remove time series points we need to provide an empty PyArrow table, but with correct schema.</span>
        <span class="n">empty_table</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">Timeseries</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">empty_table</span><span class="p">()</span>

        <span class="c1"># If `start_time` and `end_time` are not provided explicitly they will be taken from PyArrow `table`.</span>
        <span class="c1"># Because we are providing empty table we must specify them explicitly.</span>
        <span class="c1"># For this interval all existing points will be removed.</span>
        <span class="c1">#</span>
        <span class="c1"># End time is exclusive so from the 3 points written by timeseries key,</span>
        <span class="c1"># 2 points will be removed by this call.</span>
        <span class="c1">#</span>
        <span class="c1"># Send request to write time series based on time series attribute path/full_name.</span>
        <span class="n">timeseries</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">Timeseries</span><span class="p">(</span>
            <span class="n">table</span><span class="o">=</span><span class="n">empty_table</span><span class="p">,</span>
            <span class="n">start_time</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">end_time</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
            <span class="n">full_name</span><span class="o">=</span><span class="n">timeseries_attribute_path</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">session</span><span class="o">.</span><span class="n">write_timeseries_points</span><span class="p">(</span><span class="n">timeseries</span><span class="o">=</span><span class="n">timeseries</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time series points written using time series attribute path.&quot;</span><span class="p">)</span>

        <span class="c1"># Let&#39;s check it. We should get just one point.</span>
        <span class="c1"># Note:</span>
        <span class="c1"># - the `timeseries_attribute_path` and `timeseries_key` both point to the same time series attribute.</span>
        <span class="c1"># - the `end_time` in `read_timeseries_points` is also exclusive,</span>
        <span class="c1">#   but for time series with linear curve type Mesh is also returning one point after the interval.</span>
        <span class="n">timeseries</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">read_timeseries_points</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="n">timeseries_key</span><span class="p">,</span>
            <span class="n">start_time</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">end_time</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Read </span><span class="si">{</span><span class="n">timeseries</span><span class="o">.</span><span class="n">number_of_points</span><span class="si">}</span><span class="s2"> points using time series key.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">timeseries</span><span class="o">.</span><span class="n">arrow_table</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">())</span>

        <span class="c1"># Send request to write time series based on time series attribute ID.</span>
        <span class="c1"># Attribute IDs are auto-generated when an object is created.</span>
        <span class="c1"># That is why we can&#39;t use any fixed ID in this example and the code will throw.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">timeseries</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">Timeseries</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">uuid_id</span><span class="o">=</span><span class="n">timeseries_attribute_id</span><span class="p">)</span>
            <span class="n">session</span><span class="o">.</span><span class="n">write_timeseries_points</span><span class="p">(</span><span class="n">timeseries</span><span class="o">=</span><span class="n">timeseries</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time series points written using time series attribute ID.&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">grpc</span><span class="o">.</span><span class="n">RpcError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;failed to write time series points based on time series attribute ID: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Commit the changes to the database.</span>
        <span class="c1"># session.commit()</span>

        <span class="c1"># Or discard changes.</span>
        <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>


<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">async_write_timeseries_points</span><span class="p">(</span>
    <span class="n">address</span><span class="p">,</span>
    <span class="n">tls_root_pem_cert</span><span class="p">,</span>
<span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Asynchronous write time series points:&quot;</span><span class="p">)</span>

    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = mesh.aio.Connection.with_tls(address, tls_root_pem_cert)</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">aio</span><span class="o">.</span><span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">get_pa_table_from_pa_arrays</span><span class="p">()</span>

        <span class="c1"># Each time series point occupies 20 bytes. Mesh server has a limitation of 4MB inbound message size.</span>
        <span class="c1"># In case of larger data volumes please send input data in chunks.</span>
        <span class="c1"># E.g.: call multiple times `write_timeseries_points` with shorter interval.</span>

        <span class="c1"># Send request to write time series based on time series key.</span>
        <span class="n">timeseries</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">Timeseries</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">timskey</span><span class="o">=</span><span class="n">timeseries_key</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">session</span><span class="o">.</span><span class="n">write_timeseries_points</span><span class="p">(</span><span class="n">timeseries</span><span class="o">=</span><span class="n">timeseries</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time series points written using time series key.&quot;</span><span class="p">)</span>

        <span class="c1"># To only remove time series points we need to provide an empty PyArrow table, but with correct schema.</span>
        <span class="n">empty_table</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">Timeseries</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">empty_table</span><span class="p">()</span>

        <span class="c1"># If `start_time` and `end_time` are not provided explicitly they will be taken from PyArrow `table`.</span>
        <span class="c1"># Because we are providing empty table we must specify them explicitly.</span>
        <span class="c1"># For this interval all existing points will be removed.</span>
        <span class="c1">#</span>
        <span class="c1"># End time is exclusive so from the 3 points written by timeseries key,</span>
        <span class="c1"># 2 points will be removed by this call.</span>
        <span class="c1">#</span>
        <span class="c1"># Send request to write time series based on time series attribute path/full_name.</span>
        <span class="n">timeseries</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">Timeseries</span><span class="p">(</span>
            <span class="n">table</span><span class="o">=</span><span class="n">empty_table</span><span class="p">,</span>
            <span class="n">start_time</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">end_time</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
            <span class="n">full_name</span><span class="o">=</span><span class="n">timeseries_attribute_path</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">await</span> <span class="n">session</span><span class="o">.</span><span class="n">write_timeseries_points</span><span class="p">(</span><span class="n">timeseries</span><span class="o">=</span><span class="n">timeseries</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time series points written using time series attribute path.&quot;</span><span class="p">)</span>

        <span class="c1"># Let&#39;s check it. We should get just one point.</span>
        <span class="c1"># Note:</span>
        <span class="c1"># - the `timeseries_attribute_path` and `timeseries_key` both point to the same time series attribute.</span>
        <span class="c1"># - the `end_time` in `read_timeseries_points` is also exclusive,</span>
        <span class="c1">#   but for time series with linear curve type Mesh is also returning one point after the interval.</span>
        <span class="n">timeseries</span> <span class="o">=</span> <span class="k">await</span> <span class="n">session</span><span class="o">.</span><span class="n">read_timeseries_points</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="n">timeseries_key</span><span class="p">,</span>
            <span class="n">start_time</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">end_time</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Read </span><span class="si">{</span><span class="n">timeseries</span><span class="o">.</span><span class="n">number_of_points</span><span class="si">}</span><span class="s2"> points using time series key.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">timeseries</span><span class="o">.</span><span class="n">arrow_table</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">())</span>

        <span class="c1"># Send request to write time series based on time series attribute ID.</span>
        <span class="c1"># Attribute IDs are auto-generated when an object is created.</span>
        <span class="c1"># That is why we can&#39;t use any fixed ID in this example and the code will throw.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">timeseries</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">Timeseries</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">uuid_id</span><span class="o">=</span><span class="n">timeseries_attribute_id</span><span class="p">)</span>
            <span class="k">await</span> <span class="n">session</span><span class="o">.</span><span class="n">write_timeseries_points</span><span class="p">(</span><span class="n">timeseries</span><span class="o">=</span><span class="n">timeseries</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time series points written using time series attribute ID.&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">grpc</span><span class="o">.</span><span class="n">RpcError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;failed to write time series points based on time series attribute ID: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Commit the changes to the database.</span>
        <span class="c1"># await session.commit()</span>

        <span class="c1"># Or discard changes.</span>
        <span class="k">await</span> <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">get_connection_info</span><span class="p">()</span>
    <span class="n">sync_write_timeseries_points</span><span class="p">(</span>
        <span class="n">address</span><span class="p">,</span>
        <span class="n">tls_root_pem_cert</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">async_write_timeseries_points</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="run-simulations">
<h2>Run simulations<a class="headerlink" href="#run-simulations" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">helpers</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">volue.mesh.aio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">volue</span><span class="w"> </span><span class="kn">import</span> <span class="n">mesh</span>

<span class="n">GRPC_MAX_RECEIVE_MESSAGE_LENGTH_IN_BYTES</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>  <span class="c1"># 10MB</span>


<span class="k">def</span><span class="w"> </span><span class="nf">sync_run_simulation</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;connecting...&quot;</span><span class="p">)</span>

    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = mesh.Connection.with_tls(</span>
    <span class="c1">#     address,</span>
    <span class="c1">#     tls_root_pem_cert,</span>
    <span class="c1">#     grpc_max_receive_message_length=GRPC_MAX_RECEIVE_MESSAGE_LENGTH_IN_BYTES,</span>
    <span class="c1"># )</span>

    <span class="c1"># By default the maximum inbound gRPC message size is 4MB. When Mesh server</span>
    <span class="c1"># returns datasets for longer simulation intervals the gRPC message size</span>
    <span class="c1"># may exceed this limit. In such cases the user can set new limit using</span>
    <span class="c1"># `grpc_max_receive_message_length` when creating a connection to Mesh.</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span>
        <span class="n">address</span><span class="p">,</span>
        <span class="n">grpc_max_receive_message_length</span><span class="o">=</span><span class="n">GRPC_MAX_RECEIVE_MESSAGE_LENGTH_IN_BYTES</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2023</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2023</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;running simulation...&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">response</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">run_simulation</span><span class="p">(</span>
                <span class="s2">&quot;Mesh&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Cases/Demo&quot;</span><span class="p">,</span>
                <span class="n">start_time</span><span class="p">,</span>
                <span class="n">end_time</span><span class="p">,</span>
                <span class="n">return_datasets</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">resolution</span><span class="o">=</span><span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">LogMessage</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">logging</span><span class="o">.</span><span class="n">getLevelName</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">level</span><span class="p">)</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="n">response</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">HydSimDataset</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Received dataset </span><span class="si">{</span><span class="n">response</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2"> bytes&quot;</span>
                    <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;done&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;failed to run simulation: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">async_run_simulation</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;connecting...&quot;</span><span class="p">)</span>

    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = mesh.aio.Connection.with_tls(</span>
    <span class="c1">#     address,</span>
    <span class="c1">#     tls_root_pem_cert,</span>
    <span class="c1">#     grpc_max_receive_message_length=GRPC_MAX_RECEIVE_MESSAGE_LENGTH_IN_BYTES,</span>
    <span class="c1"># )</span>

    <span class="c1"># By default the maximum inbound gRPC message size is 4MB. When Mesh server</span>
    <span class="c1"># returns datasets for longer simulation intervals the gRPC message size</span>
    <span class="c1"># may exceed this limit. In such cases the user can set new limit using</span>
    <span class="c1"># `grpc_max_receive_message_length` when creating a connection to Mesh.</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">aio</span><span class="o">.</span><span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span>
        <span class="n">address</span><span class="p">,</span>
        <span class="n">grpc_max_receive_message_length</span><span class="o">=</span><span class="n">GRPC_MAX_RECEIVE_MESSAGE_LENGTH_IN_BYTES</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">async</span> <span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2023</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2023</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;running simulation...&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">async</span> <span class="k">for</span> <span class="n">response</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">run_simulation</span><span class="p">(</span>
                <span class="s2">&quot;Mesh&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Cases/Demo&quot;</span><span class="p">,</span>
                <span class="n">start_time</span><span class="p">,</span>
                <span class="n">end_time</span><span class="p">,</span>
                <span class="n">return_datasets</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">resolution</span><span class="o">=</span><span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">LogMessage</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">logging</span><span class="o">.</span><span class="n">getLevelName</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">level</span><span class="p">)</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="n">response</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">HydSimDataset</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Received dataset </span><span class="si">{</span><span class="n">response</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2"> bytes&quot;</span>
                    <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;done&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;failed to run simulation: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">get_connection_info</span><span class="p">()</span>
    <span class="n">sync_run_simulation</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">)</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">async_run_simulation</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="run-inflow-calculations">
<h2>Run inflow calculations<a class="headerlink" href="#run-inflow-calculations" title="Permalink to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">helpers</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">volue.mesh.aio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">volue</span><span class="w"> </span><span class="kn">import</span> <span class="n">mesh</span>

<span class="n">GRPC_MAX_RECEIVE_MESSAGE_LENGTH_IN_BYTES</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>  <span class="c1"># 10MB</span>


<span class="k">def</span><span class="w"> </span><span class="nf">sync_run_inflow_calculation</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;connecting...&quot;</span><span class="p">)</span>

    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = mesh.Connection.with_tls(</span>
    <span class="c1">#     address,</span>
    <span class="c1">#     tls_root_pem_cert,</span>
    <span class="c1">#     grpc_max_receive_message_length=GRPC_MAX_RECEIVE_MESSAGE_LENGTH_IN_BYTES,</span>
    <span class="c1"># )</span>

    <span class="c1"># By default the maximum inbound gRPC message size is 4MB. When Mesh server</span>
    <span class="c1"># returns datasets for longer inflow calculation intervals the gRPC message</span>
    <span class="c1"># size may exceed this limit. In such cases the user can set new limit</span>
    <span class="c1"># using `grpc_max_receive_message_length` when creating a connection to Mesh.</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span>
        <span class="n">address</span><span class="p">,</span>
        <span class="n">grpc_max_receive_message_length</span><span class="o">=</span><span class="n">GRPC_MAX_RECEIVE_MESSAGE_LENGTH_IN_BYTES</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2021</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2021</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;running inflow calculation...&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">response</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">run_inflow_calculation</span><span class="p">(</span>
                <span class="s2">&quot;Mesh&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Area&quot;</span><span class="p">,</span>
                <span class="s2">&quot;WaterCourse&quot;</span><span class="p">,</span>
                <span class="n">start_time</span><span class="p">,</span>
                <span class="n">end_time</span><span class="p">,</span>
                <span class="n">return_datasets</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">resolution</span><span class="o">=</span><span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">LogMessage</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">logging</span><span class="o">.</span><span class="n">getLevelName</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">level</span><span class="p">)</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="n">response</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">HydSimDataset</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Received dataset </span><span class="si">{</span><span class="n">response</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2"> bytes&quot;</span>
                    <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;done&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;failed to run inflow calculation: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">async_run_inflow_calculation</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;connecting...&quot;</span><span class="p">)</span>

    <span class="c1"># For production environments create connection using: with_tls, with_kerberos, or with_external_access_token, e.g.:</span>
    <span class="c1"># connection = mesh.aio.Connection.with_tls(</span>
    <span class="c1">#     address,</span>
    <span class="c1">#     tls_root_pem_cert,</span>
    <span class="c1">#     grpc_max_receive_message_length=GRPC_MAX_RECEIVE_MESSAGE_LENGTH_IN_BYTES,</span>
    <span class="c1"># )</span>

    <span class="c1"># By default the maximum inbound gRPC message size is 4MB. When Mesh server</span>
    <span class="c1"># returns datasets for longer inflow calculation intervals the gRPC message</span>
    <span class="c1"># size may exceed this limit. In such cases the user can set new limit</span>
    <span class="c1"># using `grpc_max_receive_message_length` when creating a connection to Mesh.</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">aio</span><span class="o">.</span><span class="n">Connection</span><span class="o">.</span><span class="n">insecure</span><span class="p">(</span>
        <span class="n">address</span><span class="p">,</span>
        <span class="n">grpc_max_receive_message_length</span><span class="o">=</span><span class="n">GRPC_MAX_RECEIVE_MESSAGE_LENGTH_IN_BYTES</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">async</span> <span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">create_session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2021</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2021</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;running inflow calculation...&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">async</span> <span class="k">for</span> <span class="n">response</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">run_inflow_calculation</span><span class="p">(</span>
                <span class="s2">&quot;Mesh&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Area&quot;</span><span class="p">,</span>
                <span class="s2">&quot;WaterCourse&quot;</span><span class="p">,</span>
                <span class="n">start_time</span><span class="p">,</span>
                <span class="n">end_time</span><span class="p">,</span>
                <span class="n">return_datasets</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">resolution</span><span class="o">=</span><span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">LogMessage</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">logging</span><span class="o">.</span><span class="n">getLevelName</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">level</span><span class="p">)</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="n">response</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">HydSimDataset</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Received dataset </span><span class="si">{</span><span class="n">response</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2"> bytes&quot;</span>
                    <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;done&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;failed to run inflow calculation: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">get_connection_info</span><span class="p">()</span>
    <span class="n">sync_run_inflow_calculation</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">)</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">async_run_inflow_calculation</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">tls_root_pem_cert</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="authentication.html" class="btn btn-neutral float-right" title="Client authentication" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="hydsim.html" class="btn btn-neutral float-left" title="HydSim" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2024, Volue AS.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>